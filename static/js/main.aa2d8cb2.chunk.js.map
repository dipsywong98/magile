{"version":3,"sources":["../node_modules/peerjs/dist sync","GameAction.ts","types.ts","GameState.ts","components/Deck.tsx","constants.ts","utils.ts","GameReducer.ts","aiAction.ts","withGameNetwork.tsx","assets/index.ts","assets/angel_guard.png","assets/dark_magile.png","assets/earth_mage.png","assets/earth_missile.png","assets/fire_mage.png","assets/fire_missile.png","assets/hetero_ignite.png","assets/homo_ignite.png","assets/light_magile.png","assets/thunder_mage.png","assets/thunder_missile.png","assets/water_mage.png","assets/water_missile.png","assets/wind_mage.png","assets/wind_missile.png","components/Card.tsx","Game.tsx","DamageTable.tsx","DamageTableToggleButton.tsx","components/GameRenderer.tsx","i18ns/howToPlay.en.tsx","i18ns/en.tsx","i18ns/howToPlay.zh.tsx","i18ns/index.ts","i18ns/zh.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","GameActionType","ICard","IMode","ICardType","ICardColor","GameState","maxPlayer","minPlayer","turn","direction","points","drawDeck","stage","mode","trashDeck","playerDeck","playerHp","logs","lastAction","ignited","duel","GenericBoardGameState","ChooseCardFor","allColors","EARTH","WATER","FIRE","WIND","THUNDER","LIGHT","DARK","cardCount","EARTH_MAGE","WATER_MAGE","FIRE_MAGE","WIND_MAGE","THUNDER_MAGE","EARTH_MISSILE","WATER_MISSILE","FIRE_MISSILE","WIND_MISSILE","THUNDER_MISSILE","LIGHT_MAGILE","DARK_MAGILE","HOMO_IGNITE","HETERO_IGNITE","ANGEL_GUARD","computeDamage","state","igniteCount","filter","card","getCardType","IGNITE","length","count","HOMO","HETERO","basicDamage","getCardColor","NONE","Math","max","MAGE","MISSILE","MAGILE","areCardsOfTypeOrMagile","cards","type","reduce","prev","curr","cardType","isActionCard","includes","areCardsOfDifferentColor","seenColor","Set","filteredCards","forEach","add","size","buildError","messageKey","values","variables","JSON","stringify","reorderInPlace","list","startIndex","endIndex","result","Array","from","splice","removed","reorder","i","withDrawCard","playerId","player","players","undefined","shuffle","hand","slice","withEnsureDuelNotFunctionCard","compose","withDiscardCard","withInitGame","prevState","winner","fullDeck","Object","entries","flatMap","fill","index","indexOf","withPutToPlayed","withCardNumberValidation","_","withCardTypeValidation","map","withFirstPlayValidation","withPlayHomo","cardColor","color","areCardsOfColor","withPlayHetero","find","hasCardColorNone","stageColors","colorsPlayed","colorsCanPlay","type2","withPlayIgnite","withPlayAngleGuard","withStateChangedValidation","withIncrementTurn","nextPlayerId","withCheckDiscardToHp","payload","withClearStage","GameReducer","action","peerId","nameDict","members","GameActionTypes","START","PLAY_CARD","nextState","playCard","withPlayCard","parse","DISCARD_CARD","step","TAKE_HIT","playerIdLose","findIndex","hp","withCheckWin","hit","withHit","END","started","ready","REORDER","a","b","flag","element","sortDict","dict","sort","buildPlayCardAction","aiFirstCard","byColor","excludeMagile","previousValue","currentValue","countByColor","byType","k","record","countByTypeUniqueColor","nextPlayerHp","magileCount","aiAction","amountToDiscard","discards","push","floor","random","aiDiscard","stageColor","homoIgnite","angelGuard","stageType","playableColors","has","delete","heteroIgnite","console","warn","aiPlayCard","Poker99Context","createContext","usePoker99","network","useContext","cardImages","angel_guard","dark_magile","earth_mage","earth_missile","fire_mage","fire_missile","hetero_ignite","homo_ignite","light_magile","thunder_mage","thunder_missile","water_mage","water_missile","wind_mage","wind_missile","useStyle","makeStyles","root","padding","width","height","borderRadius","cursor","userSelect","transition","transformOrigin","Card","style","onClick","disabled","selected","isDelete","classes","i18n","useGamenetI18n","Paper","elevation","pointerEvents","backgroundImage","backgroundSize","position","textAlign","className","fontFamily","margin","textShadow","top","right","CancelOutlined","red","fontSize","green","DURATION","PlaceHolder","maxWidth","useState","setWidth","useEffect","setTimeout","minWidth","Deck","hide","reveal","onCardsChoose","chooseCardFor","takeHit","myTurn","onReorder","ableToRespond","playedIndices","setPlayedIndices","hovering","setHovering","playGetCardAnimation","setPlayGetCardAnimation","discardingAnimation","setDiscardingAnimation","useReducer","isArray","dispatchSelected","handleCardClick","handlePlayCards","param","laterSetDiscardingAnimation","DISCARD","then","catch","error","getPlayedCards","cardsToRender","j","withMaxWidth","children","noPad","onMouseEnter","onTouchStart","onMouseLeave","onTouchEnd","bottom","left","zIndex","transform","display","Button","variant","Visibility","RESPOND_PLAY","title","window","confirm","areYouSureYouWantToTakeHit","Flag","marginLeft","respond","PlayArrow","notAbleToRespond","FIRST_PLAY","initializeHomoTransfer","initializeHeteroTransfer","trash","Delete","notYourTurn","onDragEnd","source","to","destination","droppableId","provided","snapshot","ref","innerRef","droppableProps","justifyContent","flexWrap","draggableId","toString","draggableProps","dragHandleProps","isDragging","placeholder","Game","dispatch","dispatchAs","myPlayerId","myLocals","hideDeck","setHideDeck","setError","renderedDeckId","throttledRenderedId","setTrottledRenderedId","handleError","message","varName","i18nKey","key","join","i18nSub","decodeError","dispatchHelper","discardCard","useMemo","checkAbleToRespond","handleCardChoose","maxHeight","reverse","s","Dialog","open","onClose","aria-labelledby","DialogTitle","DialogContent","DialogContentText","DialogActions","DamageTable","TableContainer","component","Table","TableHead","TableRow","TableCell","transferMode","mmmCount","damage","TableBody","rowSpan","homo","hetero","DamageTableToggleButton","setOpen","IconButton","damageTable","damageTableHint","close","GameRenderer","prevCardPayload","setPrevCardPayload","startAnimateCard","setStartAnimateCard","showAnimateCard","setShowAnimateCard","again","status","loserIs$player","$playerDiscardCardTil$cardCount","$playerInitializingTransfer","$playerRespondTo$modeTransfer","hint","hit$playerWith$damage","gameOver","duelHint","ignitedHint","backgroundColor","boxShadow","border","current$damage","marginRight","marginBottom","name","howToPlay","en","gamenetI18n","gameName","howToPlayContent","i18ns","zh","App","withLobby","withGamenetI18n","Component","WithGameNetwork","props","useBoardGameNetwork","myAis","n","clearTimeout","Provider","value","displayName","withGameNetwork","gameAppState","fullPage","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"yGAAA,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,EAEPF,EAAoBK,KAAO,WAAa,MAAO,IAC/CL,EAAoBM,QAAUN,EAC9BO,EAAOC,QAAUR,EACjBA,EAAoBS,GAAK,K,oPCFbC,ECHAC,EAkBAC,EAaAC,EAQAC,E,iFCpCCC,EAAb,4MAGEC,UAAY,EAHd,EAIEC,UAAY,EAJd,EAKEC,KAAO,EALT,EAMEC,UAAY,EANd,EAOEC,OAAS,EAPX,EAQEC,SAAkB,GARpB,EASEC,MAAe,GATjB,EAUEC,KAAqB,KAVvB,EAWEC,UAAmB,GAXrB,EAYEC,WAAsB,GAZxB,EAaEC,SAAqB,GAbvB,EAcEC,KAAiB,GAdnB,EAeEC,WAA4D,KAf9D,EAgBEC,SAAU,EAhBZ,EAiBEC,MAAO,EAjBT,YAA+BC,K,0BFAnBrB,O,yBAAAA,I,aAAAA,I,+BAAAA,I,uBAAAA,I,sBAAAA,M,cCHAC,K,wBAAAA,E,wBAAAA,E,sBAAAA,E,sBAAAA,E,4BAAAA,E,8BAAAA,E,8BAAAA,E,4BAAAA,E,4BAAAA,E,kCAAAA,E,4BAAAA,E,0BAAAA,E,0BAAAA,E,8BAAAA,E,2BAAAA,M,cAkBAC,K,YAAAA,E,iBAAAA,M,cAaAC,K,YAAAA,E,kBAAAA,E,gBAAAA,E,gBAAAA,E,2BAAAA,M,cAQAC,K,YAAAA,E,cAAAA,E,cAAAA,E,YAAAA,E,YAAAA,E,kBAAAA,E,cAAAA,E,aAAAA,M,KAWL,I,EEtBKkB,EFsBCC,EAA0B,CACrCnB,EAAWoB,MACXpB,EAAWqB,MACXrB,EAAWsB,KACXtB,EAAWuB,KACXvB,EAAWwB,QACXxB,EAAWyB,MACXzB,EAAW0B,M,OG1DAC,GAAS,mBACnB9B,EAAM+B,WAAa,GADA,cAEnB/B,EAAMgC,WAAa,GAFA,cAGnBhC,EAAMiC,UAAY,GAHC,cAInBjC,EAAMkC,UAAY,GAJC,cAKnBlC,EAAMmC,aAAe,GALF,cAMnBnC,EAAMoC,cAAgB,GANH,cAOnBpC,EAAMqC,cAAgB,GAPH,cAQnBrC,EAAMsC,aAAe,GARF,cASnBtC,EAAMuC,aAAe,GATF,cAUnBvC,EAAMwC,gBAAkB,GAVL,cAWnBxC,EAAMyC,aAAe,GAXF,cAYnBzC,EAAM0C,YAAc,GAZD,cAanB1C,EAAM2C,YAAc,GAbD,cAcnB3C,EAAM4C,cAAgB,GAdH,cAenB5C,EAAM6C,YAAc,GAfD,G,QCoCTC,EAAgB,SAACC,GAC5B,IAAMC,EAAcD,EAAMpC,MAAMsC,QAAO,SAAAC,GAAI,OAAIC,EAAYD,KAAUhD,EAAUkD,UAAQC,OAEvF,OArCyB,SAACC,EAAe1C,GACzC,OAAQA,GACN,KAAKX,EAAMsD,KACT,OAAQD,GACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACH,OAAO,EACT,KAAK,EACL,KAAK,EACL,KAAK,EACH,OAAO,EACT,QACE,OAAO,EAEb,KAAKrD,EAAMuD,OACT,OAAQF,GACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACH,OAAO,EACT,KAAK,EACL,KAAK,EACH,OAAO,EACT,QACE,OAAO,EAEb,QACE,OAAO,GAMGG,CAAYV,EAAMpC,MAAMsC,QAAO,SAAAC,GAAI,OAAIQ,EAAaR,KAAU/C,EAAWwD,QAAMN,OAAQN,EAAMnC,MAC5FgD,KAAKC,IAAIb,EAAc,EAAG,IAAMD,EAAM5B,KAAO,EAAI,IAGrDgC,EAAc,SAACD,GAC1B,OAAQA,GACN,KAAKlD,EAAM+B,WACX,KAAK/B,EAAMgC,WACX,KAAKhC,EAAMiC,UACX,KAAKjC,EAAMkC,UACX,KAAKlC,EAAMmC,aACT,OAAOjC,EAAU4D,KACnB,KAAK9D,EAAMoC,cACX,KAAKpC,EAAMqC,cACX,KAAKrC,EAAMsC,aACX,KAAKtC,EAAMuC,aACX,KAAKvC,EAAMwC,gBACT,OAAOtC,EAAU6D,QACnB,KAAK/D,EAAMyC,aACX,KAAKzC,EAAM0C,YACT,OAAOxC,EAAU8D,OACnB,KAAKhE,EAAM4C,cACX,KAAK5C,EAAM2C,YACT,OAAOzC,EAAUkD,OACnB,KAAKpD,EAAM6C,YACT,OAAO3C,EAAU2C,cAIVoB,EAAyB,SAACC,EAAgBC,GACrD,OAAOD,EAAME,QAAgB,SAACC,EAAMC,GAClC,IAAMC,EAAWpB,EAAYmB,GAC7B,OAAOD,IAASE,IAAaJ,GAAQI,IAAarE,EAAU8D,WAC3D,IAGQN,EAAe,SAACR,GAC3B,OAAQA,GACN,KAAKlD,EAAM+B,WACX,KAAK/B,EAAMoC,cACT,OAAOjC,EAAWoB,MACpB,KAAKvB,EAAMgC,WACX,KAAKhC,EAAMqC,cACT,OAAOlC,EAAWqB,MACpB,KAAKxB,EAAMiC,UACX,KAAKjC,EAAMsC,aACT,OAAOnC,EAAWsB,KACpB,KAAKzB,EAAMkC,UACX,KAAKlC,EAAMuC,aACT,OAAOpC,EAAWuB,KACpB,KAAK1B,EAAMmC,aACX,KAAKnC,EAAMwC,gBACT,OAAOrC,EAAWwB,QACpB,KAAK3B,EAAMyC,aACT,OAAOtC,EAAWyB,MACpB,KAAK5B,EAAM0C,YACT,OAAOvC,EAAW0B,KACpB,QACE,OAAO1B,EAAWwD,OAIXa,EAAe,SAACtB,GAC3B,OAAQ,CAAChD,EAAU6D,QAAS7D,EAAU4D,MAAMW,SAAStB,EAAYD,KAStDwB,EAA2B,SAACR,GACvC,IAAMS,EAAY,IAAIC,IAChBC,EAAgBX,EAAMjB,QAAO,SAACC,GAAD,OAAUQ,EAAaR,KAAU/C,EAAWwD,QAI/E,OAHAkB,EAAcC,SAAQ,SAAC5B,GACrByB,EAAUI,IAAIrB,EAAaR,OAEtByB,EAAUK,OAASH,EAAcxB,QAuC7B4B,EAAa,SAACC,EAAoBC,EAAiCC,GAC9E,OAAO,IAAI5F,MAAM6F,KAAKC,UAAU,CAAEJ,aAAYC,OAAM,OAAEA,QAAF,IAAEA,IAAU,GAAIC,gBA6BzDG,EAAiB,SAAIC,EAAWC,EAAoBC,GAE/D,IADA,IAAMC,EATe,SAAIH,EAAWC,EAAoBC,GACxD,IAAMC,EAASC,MAAMC,KAAKL,GADwD,EAEhEG,EAAOG,OAAOL,EAAY,GAArCM,EAF2E,oBAKlF,OAFAJ,EAAOG,OAAOJ,EAAU,EAAGK,GAEpBJ,EAIQK,CAAQR,EAAMC,EAAYC,GACjCO,EAAI,EAAGA,EAAIN,EAAOtC,OAAQ4C,IAChCT,EAAKS,GAAKN,EAAOM,ICxKfC,EAAmD,SAAnDA,EAAmDC,GAAQ,OAAI,SAAApD,GACnE,GAAIA,EAAMjC,WAAWqF,GAAU9C,QAAUN,EAAMhC,SAASoF,GACtD,MAAMlB,EAAW,yCAA0C,CACzDmB,OAAQrD,EAAMsD,QAAQF,GACtB7C,MAAM,GAAD,OAAKP,EAAMhC,SAASoF,MAG7B,IAAMjD,EAAOH,EAAMrC,SAAS,GAC5B,QAAa4F,IAATpD,EACF,OAAOgD,EAAaC,EAAbD,CAAA,2BAA4BnD,GAA5B,IAAmCrC,SAAU6F,YAAQxD,EAAMlC,WAAYA,UAAW,MAEzF,IAAM2F,EAAI,sBAAOzD,EAAMjC,WAAWqF,IAAxB,CAAmCjD,IACvCpC,EAAU,YAAOiC,EAAMjC,YAE7B,OADAA,EAAWqF,GAAYK,EACnBA,EAAKnD,OAASN,EAAMhC,SAASoF,GACxBD,EAAaC,EAAbD,CAAA,2BAA4BnD,GAA5B,IAAmCjC,aAAYJ,SAAUqC,EAAMrC,SAAS+F,MAAM,MAE9E,2BAAK1D,GAAZ,IAAmBjC,aAAYJ,SAAUqC,EAAMrC,SAAS+F,MAAM,OAK9DC,EAAoE,SAApEA,EAAoEP,GAAQ,OAAI,SAAApD,GACpF,GAAIA,EAAM5B,KAAM,CACd,IAAMqF,EAAOzD,EAAMjC,WAAWqF,GAC9B,GAAIK,EAAKvD,OAAOuB,GAAcnB,SAAWmD,EAAKnD,OAC5C,OAAOsD,YACLD,EAA8BP,GAC9BD,EAAaC,GACbS,EAAgB,CAAE1C,MAAOsC,GAAQL,GAH5BQ,CAIL5D,GAEN,OAAOA,IAGH8D,EAA6B,SAACC,GAClCA,EAAS,2BACJA,GADI,IAEPvG,KAAM,EACNC,UAAW,EACXC,OAAQ,EACRC,SAAU,GACVC,MAAO,GACPC,KAAM,KACNC,UAAW,GACXC,WAAY,GACZC,SAAU,GACVC,KAAM,GACNC,WAAY,KACZC,SAAS,EACTC,MAAM,EACN4F,OAAQ,OAEV,IAAMC,EAxDCC,OAAOC,QAAQpF,GAAWqF,SAAQ,mCAAEjE,EAAF,KAAQI,EAAR,YAAmBsC,MAAMtC,GAAO8D,KAAKlE,MAyD9E4D,EAAUpG,SAAW6F,YAAQS,GAC7B,IAAK,IAAIlH,EAAK,EAAGA,EAAKgH,EAAUT,QAAQhD,OAAQvD,IAC9CgH,EAAUhG,WAAWhB,GAAM,GAC3BgH,EAAU/F,SAASjB,GAAM,EACzBgH,EAAYZ,EAAapG,EAAboG,CAAiBY,GAE/B,OAAO,eAAKA,IAGRF,EAA6B,SAAC,EAAWT,GAAZ,IAAGjC,EAAH,EAAGA,MAAH,OAAyB,SAAAnB,GAC1D,IAAMlC,EAAS,sBAAOkC,EAAMlC,WAAb,YAA2BqD,IACpCsC,EAAI,YAAOzD,EAAMjC,WAAWqF,IAClCjC,EAAMY,SAAQ,SAAC5B,GACb,IAAMmE,EAAQb,EAAKc,QAAQpE,GAC3B,IAAe,IAAXmE,EACF,MAAMpC,EAAW,6BAA8B,CAAEmB,OAAQrD,EAAMsD,QAAQF,IAAa,CAAEjD,SAExFsD,EAAKV,OAAOuB,EAAO,MAErB,IAAMvG,EAAU,YAAOiC,EAAMjC,YAE7B,OADAA,EAAWqF,GAAYK,EAChB,2BAAKzD,GAAZ,IAAmBlC,YAAWC,iBAG1ByG,EAA6B,SAAC,GAAD,IAAGrD,EAAH,EAAGA,MAAH,OAAe,SAACnB,GACjD,OAAO,2BAAKA,GAAZ,IAAmBpC,MAAM,GAAD,mBAAMoC,EAAMpC,OAAZ,YAAsBuD,QAG1CsD,EAAsC,SAACC,EAAGtB,GAAJ,OAAiB,SAACpD,GAC5D,GAAIA,EAAMjC,WAAWqF,GAAU9C,OAASN,EAAMhC,SAASoF,GACrD,MAAMlB,EAAW,wBAEnB,OAAOlC,IAGH2E,EAAoC,SAAC,EAAWvB,GAAZ,IAAGjC,EAAH,EAAGA,MAAH,OAAyB,SAAAnB,GACjE,GAAqB,IAAjBmB,EAAMb,OAAc,CACtB,GAAIa,EAAMyD,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MAAOuB,SAAStE,EAAWwD,MAC5D,MAAMsB,EAAW,mCAEnB,GAAIlC,EAAM5B,MACJ+C,EAAMyD,KAAI,SAAAzE,GAAI,OAAIC,EAAYD,MAAOuB,SAASvE,EAAU8D,QAC1D,MAAMiB,EAAW,oCAGhB,IAAqB,IAAjBf,EAAMb,OAQf,MAAM4B,EAAW,wBAPjB,GAAIlC,EAAM5B,KAAM,CACd,IAAMoD,EAAWpB,EAAYe,EAAM,IACnC,GAAI,CAAChE,EAAU8D,OAAQ9D,EAAUkD,OAAQlD,EAAU2C,aAAa4B,SAASF,GACvE,MAAMU,EAAW,iCAMvB,OAAOlC,IAGH6E,EAAqC,SAAC,EAAiBzB,GAAlB,IAAGjC,EAAH,EAAGA,MAAOtD,EAAV,EAAUA,KAAV,OAA+B,SAACmC,GACzE,GAA2B,IAAvBA,EAAMpC,MAAM0C,OAAc,CAC5B,GAAa,OAATzC,QAA0B0F,IAAT1F,EACnB,MAAMqE,EAAW,sCAEnB,GAAIrE,IAASX,EAAMsD,MAAkE,IAA1DR,EAAMhC,UAAUoF,EAAW,GAAKpD,EAAMsD,QAAQhD,QACvE,MAAM4B,EAAW,gCAEnB,GAAqB,IAAjBf,EAAMb,OACR,MAAM4B,EAAW,uCAEnB,GAAI9B,EAAYe,EAAM,MAAQhE,EAAU4D,MAAQX,EAAYe,EAAM,MAAQhE,EAAU6D,QAClF,MAAMkB,EAAW,6CAEnB,OAAO,2BAAKlC,GAAZ,IAAmBnC,SAErB,OAAOmC,IAGH8E,EAA0B,SAAC,GAAD,IAAG3D,EAAH,EAAGA,MAAH,OAAe,SAAAnB,GAC7C,GAAIA,EAAMnC,OAASX,EAAMsD,OAASR,EAAM7B,QAAS,CAC/C,GAA2B,IAAvB6B,EAAMpC,MAAM0C,OACd,OAAO,eAAKN,GAEd,IAAM+E,EAAYpE,EAAaQ,EAAM,IACrC,GAAI4D,IAAc3H,EAAWwD,KAAM,CACjC,IDtDyB,SAACO,EAAgB6D,GAC9C,OAAO7D,EAAME,QAAgB,SAACC,EAAMC,GAClC,OAAOD,GAAQX,EAAaY,KAAUyD,KACrC,GCmDMC,CAAgB9D,EAAOR,EAAaX,EAAMpC,MAAM,KACnD,MAAMsE,EAAW,sCAAuC,GAAI,CAAE8C,MAAOD,IAEvE,OAAO,eAAK/E,IAGhB,OAAOA,IAGHkF,EAA4B,SAAC,GAAD,IAAG/D,EAAH,EAAGA,MAAH,OAAe,SAAAnB,GAC/C,GAAIA,EAAMnC,OAASX,EAAMuD,SAAWT,EAAM7B,QAAS,CACjD,GAA2B,IAAvB6B,EAAMpC,MAAM0C,OACd,OAAO,eAAKN,GAEd,IDrD4B,SAACmB,GAC/B,QAASA,EAAMgE,MAAK,SAAChF,GAAD,OAAUQ,EAAaR,KAAU/C,EAAWwD,QCoDzDwE,CAAiBjE,GAAQ,CAC5B,IAAMC,EAAOhB,EAAYJ,EAAMpC,MAAM,IACrC,GAAK+D,EAAyB,GAAD,mBAAK3B,EAAMpC,OAAX,YAAqBuD,KAU3C,CACL,GAAKD,EAAuBC,EAAOC,GAOjC,OAAO,eAAKpB,GANZ,MAAIA,EAAM5B,KACF8D,EAAW,sBAAuB,GAAI,CAAEd,SAExCc,EAAW,8BAA+B,GAAI,CAAEd,SAd1D,IAAMiE,EAAcrF,EAAMpC,MAAMgH,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MACnDmF,EAAenE,EAAMyD,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MAAOD,QAAO,SAAA8E,GAAK,OAAIK,EAAY3D,SAASsD,MAC1FO,EAAgBhH,EAAU2B,QAAO,SAAA8E,GAAK,OAAKK,EAAY3D,SAASsD,MACtE,MAAM9C,EAAW,0DAA2D,GAAI,CAC9Ed,OACAoE,MAAOpE,EACPkE,eACAC,mBAeR,OAAOvF,IAGHyF,EAA4B,SAAC,GAAD,IAAGtE,EAAH,EAAGA,MAAH,OAAe,SAAAnB,GAC/C,GAAqB,IAAjBmB,EAAMb,OAAc,CACtB,IAAMH,EAAOgB,EAAM,GACnB,GAAIhB,IAASlD,EAAM4C,cAAe,CAChC,GAAIG,EAAMnC,OAASX,EAAMuD,OACvB,OAAO,2BAAKT,GAAZ,IAAmB7B,SAAS,IAE5B,MAAM+D,EAAW,4CAGrB,GAAI/B,IAASlD,EAAM2C,YAAa,CAC9B,GAAII,EAAMnC,OAASX,EAAMsD,KACvB,OAAO,2BAAKR,GAAZ,IAAmB7B,SAAS,IAE5B,MAAM+D,EAAW,6CAIvB,OAAOlC,IAGH0F,EAAgC,SAAC,GAAD,IAAGvE,EAAH,EAAGA,MAAH,OAAe,SAAAnB,GACnD,OAAqB,IAAjBmB,EAAMb,QACJa,EAAM,KAAOlE,EAAM6C,YACd,eAAKE,GAGTA,IAGH2F,EAA6B,SAAC5B,GAAD,OAAqC,kBAAM,SAAA/D,GAC5E,GAAI+D,IAAc/D,EAChB,MAAMkC,EAAW,eAEnB,OAAOlC,KAGI4F,EAAkC,SAAA7B,GAC7C,IAAM8B,GAAgB9B,EAAUvG,KAAOuG,EAAUT,QAAQhD,OAASyD,EAAUtG,WAAasG,EAAUT,QAAQhD,OAC3G,OAAO,2BAAKyD,GAAZ,IAAuBvG,KAAMqI,KA+DzBC,EAAkC,SAACC,EAAS3C,GAAV,OAAuB,SAAApD,GAC7D,GAAIA,EAAMjC,WAAWqF,GAAU9C,OAASyF,EAAQ5E,MAAMb,SAAWN,EAAMhC,SAASoF,GAAW,CACzF,IAAM7C,EAAK,UAAMP,EAAMjC,WAAWqF,GAAU9C,OAASN,EAAMhC,SAASoF,IACpE,MAAMlB,EAAW,2BAA4B,CAAE3B,UAEjD,OAAOP,IAGHgG,EAA+B,SAAAhG,GACnC,OAAO,2BACFA,GADL,IAEEpC,MAAO,GACPE,UAAU,YAAKkC,EAAMpC,OACrBM,WAAY,KACZC,SAAS,EACTC,KAAM4B,EAAM5B,MAAQ4B,EAAMhC,SAASgC,EAAMxC,OAAS,EAClDK,KAAM,QAaGoI,EAAqD,SAAClC,EAAWmC,GAC5E,IAAMC,EAASD,EAAOC,OACtB,QAAe5C,IAAX4C,EACF,MAAM,IAAI1J,MAAM,2BAElB,IAAM2G,EAAW,WACf,IAAMrG,EAAKgH,EAAUqC,SAASrC,EAAUsC,QAAQF,IAChD,QAAW5C,IAAPxG,EACF,MAAM,IAAIN,MAAM,oBAElB,OAAOM,GAET,OAAQmJ,EAAO9E,MACb,KAAKkF,IAAgBC,MACnB,OAAOzC,EAAaC,GACtB,KAAK/G,EAAewJ,UAClB,OAzG6E,SAACpD,EAAU2C,GAAX,OAAuB,SAAAhC,GACxG,GAAIA,EAAUvG,OAAS4F,EACrB,MAAMlB,EAAW,eAEnB,IAAMuE,EAAY7C,IAAO,WAAP,GAGhBgC,EACAjC,EAA8BP,GAC9BD,EAAaC,IALG,mBAMb,CACDoB,EACAX,EACA8B,EAA2B5B,GAC3B2B,EACAD,EACAP,EACAJ,EACAH,EACAE,EACAJ,GACAG,KAAI,SAAA8B,GAAQ,OAAIA,EAASX,EAAS3C,QAjBpBQ,CAkBhBG,GACF,OAAO,2BAAK0C,GAAZ,IAAuBvI,WAAW,2BAAM6H,GAAP,IAAgB3C,gBAkFtCuD,CAAavD,IAAY8C,EAAOH,QAAhCY,CAAyCrE,KAAKsE,MAAMtE,KAAKC,UAAUwB,KAC5E,KAAK/G,EAAe6J,aAClB,OAAOjD,IAAO,WAAP,GAAQD,EAA8BP,KAAa4C,GAAnD,mBAAsE,CAACnC,EAAiBiC,GAAsBlB,KAAI,SAAAkC,GAAI,OAAIA,EAAKZ,EAAOH,QAAS3C,UAA/IQ,CAA6JtB,KAAKsE,MAAMtE,KAAKC,UAAUwB,KAChM,KAAK/G,EAAe+J,SAClB,OAnFoC,SAAA/G,GACxC,IAAMgH,EAAehH,EAAMhC,SAASiJ,WAAU,SAAAC,GAAE,OAAIA,GAAM,KAC1D,OAAsB,IAAlBF,EACK,2BAAKhH,GAAZ,IAAmBgE,OAAQgD,IAEtBhH,EA8EImH,CAnEG,SAACnH,GACf,GAAmB,OAAfA,EAAMnC,KAAe,CAAC,IAChBL,EAASwC,EAATxC,KACF4J,EAAMrH,EAAcC,GACpBhC,EAAQ,YAAOgC,EAAMhC,UAE3B,OADAA,EAASR,IAAS4J,EACX,2BACFpH,GADL,IAEEhC,aAGJ,OAAOgC,EAwDiBqH,CAAQtD,IAC9B,KAAK/G,EAAesK,IAClB,OAAO,2BAAKvD,GAAZ,IAAuBwD,SAAS,EAAOC,MAAO,KAChD,KAAKxK,EAAeyK,QAClB,OAjCU,SAACtG,EAAciC,GAAf,OAAoC,SAACpD,GACnD,GDxJkC0H,ECwJZvG,EDxJoBwG,ECwJb3H,EAAMjC,WAAWqF,KDvJ3CsE,IAAMC,GACND,EAAEpH,SAAWqH,EAAErH,QACXoH,EAAErG,QAAgB,SAACuG,EAAMC,GAAP,OAAmBD,GAAQF,EAAExH,QAAO,SAAA1D,GAAC,OAAIA,IAAMqL,KAASvH,SAAWqH,EAAEzH,QAAO,SAAA1D,GAAC,OAAIA,IAAMqL,KAASvH,UAAQ,ICsJ/H,MAAM,IAAI7D,MAAM,wBDzJY,IAAIiL,EAAQC,EC2JpC5J,EAAU,YAAOiC,EAAMjC,YAE7B,OADAA,EAAWqF,GAAYjC,EAChB,2BAAKnB,GAAZ,IAAmBjC,gBA2BRkF,CAAQiD,EAAOH,QAAQ5E,MAAOiC,IAA9BH,CAA0Cc,GAErD,OAAOA,GCjUH+D,EAAW,SAA6BC,GAC5C,OAAO7D,OAAOC,QAAgB4D,GAAMC,MAAK,SAACN,EAAGC,GAAJ,OAAWA,EAAE,GAAKD,EAAE,OAGzDO,EAAsB,SAAC9G,EAAgBtD,GAC3C,MAAO,CACLuD,KAAMpE,EAAewJ,UACrBT,QAAS,CACP5E,QACAtD,UAyBAqK,EAAc,SAAClI,EAAkBxC,GACrC,IAAMiG,EAAa,YAAOzD,EAAMjC,WAAWP,IACrC2K,EAAuCL,EArE1B,SAACrE,EAAa2E,GACjC,OAAO3E,EACJmB,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MACzBD,QAAO,SAAA8E,GAAK,OAAIA,IAAU5H,EAAWwD,QACrCV,QAAO,SAAA8E,GAAK,OAAKoD,IAAkB,CAAChL,EAAWyB,MAAOzB,EAAW0B,MAAM4C,SAASsD,MAChF3D,QAAoC,SAACgH,EAAeC,GAAhB,yBAAC,eACjCD,GADgC,kBAElCC,GAAe,UAACD,EAAcC,UAAf,QAAgC,GAAK,MAClD,IA6D+CC,CAAa9E,GAAM,IACnE+E,EAAqCV,EA3Dd,SAACrE,EAAa2E,GAC3C,OAAO3E,EACJvD,QAAO,SAAAC,GAAI,OAAIQ,EAAaR,KAAU/C,EAAWwD,QACjDV,QAAO,SAACC,EAAMsI,EAAGtH,GAAV,OAAoBA,EAAMoD,QAAQpE,KAAUsI,KACnDpH,QAAmC,SAACqH,EAAQvI,GAAU,IAAD,EAKH,MAJ3CiB,EAAkBhB,EAAYD,GACpC,OAAGiB,IAASjE,EAAU8D,QAAUmH,EACvBM,EAELtH,IAASjE,EAAU8D,QAAWmH,EAM3B,2BACFM,GADL,kBAEGtH,GAAO,UAACsH,EAAOtH,UAAR,QAAiB,GAAK,KAPvB,EAAP,iBACGjE,EAAU6D,SAAU,UAAC0H,EAAOvL,EAAU6D,gBAAlB,QAA8B,GAAK,GAD1D,cAEG7D,EAAU4D,MAAO,UAAC2H,EAAOvL,EAAU4D,aAAlB,QAA2B,GAAK,GAFpD,KASA,IAwC8C4H,CAAuBlF,EAAMzD,EAAM5B,OACjFwK,EAAe5I,EAAMhC,UAAUR,EAAO,GAAKwC,EAAMhC,SAASsC,QAC1DuI,EAAcpF,EAAKvD,QAAO,SAAAC,GAAI,OAAIC,EAAYD,KAAUhD,EAAU8D,UAAQX,OAC1EzC,EAAgC,IAAzBmC,EAAMhC,SAASR,IAAgC,IAAjBoL,GAAwBT,EAAQ,GAAG,GAAK,GAAKK,EAAO,GAAG,IAAMK,EAAcL,EAAO,GAAG,GAAmBtL,EAAMuD,OAAnBvD,EAAMsD,KAC5I,OAAI3C,IAASX,EAAMsD,KACVyH,EAAoB,CAACxE,EAAK0B,MAAK,SAAChF,GAAD,OAAUQ,EAAaR,KAAUgI,EAAQ,GAAG,OAAetK,GAE1FoK,EAAoB,CAACxE,EAAK0B,MAAK,SAAChF,GAAD,OAAUC,EAAYD,KAAUqI,EAAO,GAAG,OAAe3K,IAkEtFiL,GAAW,SAAC9I,EAAkBxC,GACzC,OAAIwC,EAAMjC,WAAWP,GAAM8C,OAASN,EAAMhC,SAASR,GAjGnC,SAACwC,EAAkBxC,GACnC,IFoGsBsD,EEpGhB2C,EAAa,YAAOzD,EAAMjC,WAAWP,IACrCuL,EAAkBtF,EAAKnD,OAASN,EAAMhC,SAASR,GAC/CwL,EAAoB,GAC1B,GAAIhJ,EAAM5B,KACR,KAAO4K,EAAS1I,OAASyI,GAAmBtF,EAAK0B,KAAK1D,IACpDuH,EAASC,KAAKxF,EAAKV,OAAOU,EAAKwD,UAAUxF,GAAe,GAAG,IAG/D,KAAOuH,EAAS1I,OAASyI,GACvBC,EAASC,KAAKxF,EAAKV,QF2FCjC,EE3Fc2C,EAAKnD,OF4FlCO,KAAKqI,MAAMrI,KAAKsI,SAAWrI,IE5FgB,GAAG,IAErD,MAAO,CACLM,KAAMpE,EAAe6J,aACrBd,QAAS,CACP5E,MAAO6H,IAmFFI,CAAUpJ,EAAOxC,GAEC,IAAvBwC,EAAMpC,MAAM0C,OACP4H,EAAYlI,EAAOxC,GAnEX,SAACwC,EAAkBoD,GACpC,IAAMK,EAAOzD,EAAMjC,WAAWqF,GACtBvF,EAAwBmC,EAAxBnC,KAAMM,EAAkB6B,EAAlB7B,QAASC,EAAS4B,EAAT5B,KACvB,GAAIP,IAASX,EAAMsD,KAAM,CACvB,IAAIrC,EAAS,CACX,IAAMkL,EAAa1I,EAAaX,EAAMpC,MAAM,IACtCuD,EAAQsC,EAAKvD,QAAO,SAAAC,GAAI,OAAIQ,EAAaR,KAAUkJ,KACzD,GAAIlI,EAAMb,OAAS,EACjB,OAAO2H,EAAoB9G,EAAMuC,MAAM,EAAG,IAE5C,GAAIvC,EAAMb,OAAS,EACjB,OAAO2H,EAAoB,CAAC9G,EAAM,KAGtC,IAAI/C,EAAM,CACR,IAAMkL,EAAa7F,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM2C,eACpD,GAAG0J,EACD,OAAOrB,EAAoB,CAACqB,IAE9B,IAAMC,EAAa9F,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM6C,eACpD,GAAGyJ,EACD,OAAOtB,EAAoB,CAACsB,SAG3B,CACL,IAAIpL,EAAS,CACX,IAAMkH,EAAcrF,EAAMpC,MAAMgH,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MACnDqJ,EAAYpJ,EAAYJ,EAAMpC,MAAM,IACpC6L,EAAiB,IAAI5H,IAAItD,EAAU2B,QAAO,SAAA8E,GAAK,OAAKK,EAAY3D,SAASsD,OACzE7D,EAAQsC,EAAKvD,QAAO,SAAAC,GACxB,IAAM4E,EAAYpE,EAAaR,GAC/B,QAAGC,EAAYD,KAAUqJ,IAAaC,EAAeC,IAAI3E,MACvD0E,EAAeE,OAAO5E,IACf,MAKX,GAAI5D,EAAMb,OAAS,EACjB,OAAO2H,EAAoB9G,EAAMuC,MAAM,EAAG,IAE5C,GAAIvC,EAAMb,OAAS,EACjB,OAAO2H,EAAoB,CAAC9G,EAAM,KAGtC,IAAI/C,EAAM,CACR,IAAMwL,EAAenG,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM4C,iBACtD,GAAG+J,EACD,OAAO3B,EAAoB,CAAC2B,IAE9B,IAAML,EAAa9F,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM6C,eACpD,GAAGyJ,EACD,OAAOtB,EAAoB,CAACsB,KAKlC,OADAM,QAAQC,KAAK,yCAA0C9J,EAAOoD,GACvD,CACLhC,KAAMpE,EAAe+J,UAWhBgD,CAAW/J,EAAOxC,ICpJrBwM,GAAiBC,wBAAuE,MA6BjFC,GAAa,WACxB,IAAMC,EAAmEC,qBAAWJ,IACpF,GAAgB,OAAZG,EACF,MAAM,IAAI1N,MAAM,iEAElB,OAAO0N,G,iDCzBIE,GAAa,CACxBC,YCjBa,IAA0B,wCDkBvCC,YElBa,IAA0B,wCFmBvCC,WGnBa,IAA0B,uCHoBvCC,cIpBa,IAA0B,0CJqBvCC,UKrBa,IAA0B,sCLsBvCC,aMtBa,IAA0B,yCNuBvCC,cOvBa,IAA0B,0CPwBvCC,YQxBa,IAA0B,wCRyBvCC,aSzBa,IAA0B,yCT0BvCC,aU1Ba,IAA0B,yCV2BvCC,gBW3Ba,IAA0B,4CX4BvCC,WY5Ba,IAA0B,uCZ6BvCC,ca7Ba,IAA0B,0Cb8BvCC,Uc9Ba,IAA0B,sCd+BvCC,ae/Ba,IAA0B,0C,iDCSnCC,GAAWC,cAAW,iBAAO,CACjCC,KAAM,CACJC,QAAS,OACTC,MAAO,QACPC,OAAQ,QACRC,aAAc,MACdC,OAAQ,UACRC,WAAY,OACZC,WAAY,6BACZC,gBAAiB,SACjB,UAAW,QAMFC,GAER,SAAC,GAQG,IANLC,EAMI,EANJA,MACA9L,EAKI,EALJA,KACA+L,EAII,EAJJA,QACAC,EAGI,EAHJA,SACAC,EAEI,EAFJA,SACAC,EACI,EADJA,SAEIC,EAAUjB,KACTkB,EAAQC,cAARD,KAEP,OACE,eAACE,GAAA,EAAD,CACEC,UAAW,EACXT,MAAK,aACHU,cAAeR,EAAW,OAAS,OACnCS,gBAAgB,OAAD,OAASvC,GAAWlK,GAApB,KACf0M,eAAgB,QAChBC,SAAU,WACVC,UAAW,QACRd,GAELe,UAAWV,EAAQf,KAAMW,QAAUC,OAAqB5I,EAAV2I,EAVhD,UAWE,oBAAID,MAAO,CAAEgB,WAAY,qCAAsCC,OAAQ,EAAGlI,MAAO,QAASmI,WAAY,qBAAtG,SACGZ,EAAKpM,KAEPiM,GAAY,qBAAKH,MAAO,CAACa,SAAU,WAAYM,IAAK,EAAGC,MAAO,GAAlD,SACVhB,EAAW,cAACiB,GAAA,EAAD,CAAgBrB,MAAO,CAAEjH,MAAOuI,KAAI,MAAQC,SAAS,UAAY,cAAC,KAAD,CAAoBvB,MAAO,CAAEjH,MAAOyI,KAAM,MAAQD,SAAS,gB,qGtB5C1IE,GAAW,GAEXC,GAAwF,SAAC,GAAyB,IAAvBC,EAAsB,EAAtBA,SAAU3B,EAAY,EAAZA,MAAY,EAC3F4B,mBAASD,GADkF,mBAC9GnC,EAD8G,KACvGqC,EADuG,KAOrH,OALAC,qBAAU,WACRC,YAAW,WACTF,EAAS,OACR,KACF,IAED,qBAAK7B,MAAK,aACR2B,SAAUnC,EACVwC,SAAUxC,EACVK,WAAW,aAAD,OAAe4B,GAAf,iBACVZ,SAAU,YACPb,O,SAKG3N,O,2BAAAA,I,+BAAAA,I,sBAAAA,M,KAML,I,MAAM4P,GAER,SAAC,GAAsG,IAApG/M,EAAmG,EAAnGA,MAAOgN,EAA4F,EAA5FA,KAAMC,EAAsF,EAAtFA,OAAQC,EAA8E,EAA9EA,cAAeC,EAA+D,EAA/DA,cAAeC,EAAgD,EAAhDA,QAASC,EAAuC,EAAvCA,OAAQC,EAA+B,EAA/BA,UAAWC,EAAoB,EAApBA,cAAoB,EAC/Db,mBAAmB,IAD4C,mBAClGc,EADkG,KACnFC,EADmF,OAEzEf,mBAAwB,MAFiD,mBAElGgB,EAFkG,KAExFC,EAFwF,OAGjDjB,oBAAS,GAHwC,mBAGlGkB,EAHkG,KAG5EC,EAH4E,OAInDnB,oBAAS,GAJ0C,mBAIlGoB,EAJkG,KAI7EC,EAJ6E,KAKjG3C,EAASC,cAATD,KALiG,EAMpE4C,sBAAmG,SAAC7N,EAAD,GAGjI,IAFLF,EAEI,EAFJA,KACA2E,EACI,EADJA,QAEA,OAAQ3E,GACN,IAAK,MAIH,YAHgBmC,IAAZwC,GAA0BlD,MAAMuM,QAAQrJ,KAC1CzE,EAAKyE,IAAW,GAEX,YAAIzE,GACb,IAAK,SAIH,YAHgBiC,IAAZwC,GAA0BlD,MAAMuM,QAAQrJ,KAC1CzE,EAAKyE,IAAW,GAEX,YAAIzE,GACb,IAAK,QACH,MAAO,GACT,IAAK,WACH,OAAIuB,MAAMuM,QAAQrJ,GACT,YAAIA,GAENzE,EACT,QACE,OAAOA,KAEV,IA/BsG,mBAMlG8K,EANkG,KAMxFiD,EANwF,KAgCnGC,EAAe,yCAAG,WAAOnP,EAAamE,GAApB,UAAAoD,EAAA,sDAClB0E,EAAS9H,GACX+K,EAAiB,CAAEjO,KAAM,SAAU2E,QAASzB,IAE5C+K,EAAiB,CAAEjO,KAAM,MAAO2E,QAASzB,IAJrB,2CAAH,wDAOfiL,EAAkB,SAACC,GACvB,IAAM3R,EAAO2R,IAAUtS,EAAMsD,MAAQgP,IAAUtS,EAAMuD,OAAS+O,OAAQjM,EAChEkM,EAA8BnB,IAAkBhQ,EAAcoR,QACpErB,EAAc,CAAElN,MAAOA,EAAMjB,QAAO,SAACwE,EAAG+D,GAAJ,OAAU2D,EAAS3D,MAAK5K,SACzD8R,MAAK,WACJT,EAAuBO,GACvBX,EAAY,MACZF,EAAiBxC,EAASxH,KAAI,SAAC+C,EAAGc,GAAJ,MAAkB,CAACd,EAAGc,MAAIvI,QAAO,0CAAY0E,KAAI,wDAC/EyK,EAAiB,CAAEjO,KAAM,UACzB4M,YAAW,WACTgB,GAAwB,KACvB,GACHhB,YAAW,WACTgB,GAAwB,GACxBJ,EAAiB,IACjBM,GAAuB,KACtB,QAEJU,OAAM,SAAApT,GACLqN,QAAQgG,MAAMrT,OAGdsT,EAAiB,WAGrB,IAFA,IAAMC,EAAgB,GAClBC,EAAI,EACC9M,EAAI,EAAGA,EAAI/B,EAAMb,OAAQ4C,IAC5ByL,EAAcjN,SAASwB,GACzB6M,EAAc9G,KAAK,OAEnB8G,EAAc9G,KAAK9H,EAAM6O,IACzBA,KAGJ,OAAOf,EAAmB,UAAOc,EAAP,YAAyB5O,EAAMuC,MAAMsM,KAAMD,GAejEE,EAAe,SAACC,EAAqB5L,GAAtB,IAAqC6L,EAArC,+DACnB,qBACElE,MAAO,CACLT,QAAS2E,EAAQ,EAAI,MACrBvC,SAAS,gBAAD,OAAkBzM,EAAMb,OAAS,EAAjC,KACRwL,WAAW,aAAD,OAAe4B,GAAW,EAA1B,kBAEZ0C,aAAc,kBAAMtB,EAAYxK,IAChC+L,aAAc,kBAAMvB,EAAYxK,IAChCgM,aAAc,kBAAMxB,EAAY,OAChCyB,WAAY,kBAAMzB,EAAY,OAThC,SAUGoB,KAGL,OAAO,sBAAKjE,MAAO,CACjBa,SAAU,WACV0D,OAAQrC,EAAO,SAAW,SAC1BsC,KAAM,EACNpD,MAAO,EACPqD,OAAQ,EACR5E,WAAW,0BACXa,cAAe,QAPV,UASL,qBAAKV,MAAO,CACVc,UAAW,SACX4D,UAAW,oBACXzD,OAAQ,OACR0D,QAAS,QACTjE,cAAe,OALjB,SAOG6B,EAAS,qCACPL,GAAQ,cAAC0C,GAAA,EAAD,CAAQC,QAAQ,YAAY5E,QAASkC,EAArC,SACP,cAAC2C,GAAA,EAAD,OAEA5C,GAAQG,IAAkBhQ,EAAc0S,cAAgB,qCACxD,cAACH,GAAA,EAAD,CAAQC,QAAQ,YACRG,MAAO1E,EAAKgC,QACZvJ,MAAM,YACNkH,QAAS,mBAAQwC,GAAiBwC,OAAOC,QAAQ5E,EAAK6E,8BAAgC7C,IAAUqB,MAAM/F,QAAQgG,QAHtH,SAKE,cAACwB,GAAA,EAAD,MAEF,cAACR,GAAA,EAAD,CAAQ5E,MAAO,CAAEqF,WAAY,OAASR,QAAQ,YACtCG,MAAO1E,EAAKgF,QACZvM,MAAM,UACNkH,QAASqD,EAHjB,SAKE,cAACiC,GAAA,EAAD,OAEA9C,GAAiB,sBAAKzC,MAAO,CAACqF,WAAY,OAAzB,cAAmC/E,EAAKkF,iBAAxC,WAEnBtD,GAAQG,IAAkBhQ,EAAcoT,YAAc,qCACtD,cAACb,GAAA,EAAD,CAAQC,QAAQ,YACRG,MAAO1E,EAAKoF,uBACZ3M,MAAM,UACNkH,QAAS,kBAAMqD,EAAgBrS,EAAMsD,OAH7C,SAKE,cAAC,KAAD,MAEF,cAACqQ,GAAA,EAAD,CAAQ5E,MAAO,CAAEqF,WAAY,OAASR,QAAQ,YACtCG,MAAO1E,EAAKqF,yBACZ5M,MAAM,UACNkH,QAAS,kBAAMqD,EAAgBrS,EAAMuD,SAH7C,SAKE,cAAC,KAAD,UAGF0N,GAAQG,IAAkBhQ,EAAcoR,SAAW,mCACnD,cAACmB,GAAA,EAAD,CAAQC,QAAQ,YACR9L,MAAM,YACNiM,MAAO1E,EAAKsF,MACZ3F,QAASqD,EAHjB,SAKE,cAACuC,GAAA,EAAD,WAGAvF,EAAKwF,cAEb,cAAC,KAAD,CAAiBC,UA3FD,SAACpP,GAAwB,IAAD,EAClCE,EAAOF,EAAOqP,OAAO3N,MACrB4N,EAAE,UAAGtP,EAAOuP,mBAAV,aAAG,EAAoB7N,WAClBf,IAATT,QAA6BS,IAAP2O,IACxB1P,EAAerB,EAAO2B,EAAMoP,GAC5B1P,EAAe4J,EAAUtJ,EAAMoP,GAC/B7C,EAAiB,CACfjO,KAAM,WACN2E,QAASqG,IAEXqC,EAAUtN,GAAOyO,MAAM/F,QAAQgG,SAiFjC,SACE,cAAC,KAAD,CAAWuC,YAAY,YAAY3U,UAAU,aAA7C,SACG,SAAC4U,EAAUC,GAAX,OACC,6CAAKC,IAAKF,EAASG,UAAcH,EAASI,gBAA1C,aACE,sBAAKxG,MAAO,CAAE2E,QAAS,OAAQ8B,eAAgB,SAAUC,SAAU,UAAnE,UAEI7C,IAAiBlL,KAAI,SAACzE,EAAMmE,GAAP,OACnB,cAAC,KAAD,CAAWA,MAAOA,EAAOsO,YAAatO,EAAMuO,WAA5C,SACG,SAACR,EAAUC,GAAX,OACC,yDAAKC,IAAKF,EAASG,UACVH,EAASS,gBACTT,EAASU,iBAFlB,aAGW,OAAT5S,EACI,cAAC,GAAD,CAAyByN,SAAQ,uBAAkBzM,EAAMb,OAAS,EAAjC,aAAfgE,GAClB2L,EAAa,cAAC,GAAD,CACb9P,KAAMA,EACN+L,QAAS,kBAAOoG,EAASU,YAAc1D,EAAgBnP,EAAMmE,IAC7D6H,SAAUgC,EACVlC,MAAO,CAAE0E,UAAY2B,EAASU,YAAenE,IAAavK,IAAS8H,EAAS9H,QAA+Bf,EAArB,oBACtF6I,SAAUA,EAAS9H,GACnB+H,SAAUiC,IAAkBhQ,EAAcoR,UACxCpL,YAKf+N,EAASY,YACTtE,EAAcrO,OAAS,IAAM2O,GAC9B,cAAC,KAAD,CAAW3K,MAAOnD,EAAMb,OAAS,EAAGsS,YAAY,WAAhD,SACG,SAACP,EAAUC,GAAX,OACC,yDAAKC,IAAKF,EAASG,UACVH,EAASS,gBACTT,EAASU,iBAFlB,aAGE,qBAAK9G,MAAO,CACV2B,SAAUmB,EAAoB,wBAAoB5N,EAAMb,OAAS,EAAnC,sBAAkDqO,EAAcrO,OAAhE,KAA4E,IAC1GwL,WAAW,aAAD,OAAe4B,GAAf,iBACVkD,QAAS,OACT+B,SAAU,UAJZ,SAOIxR,EAAMuC,MAAMvC,EAAMb,OAASqO,EAAcrO,QAAQsE,KAAI,SAACzE,EAAMmE,GAAP,OACnD2L,EACE,cAAC,GAAD,CACE9P,KAAMA,EACN+L,QAAS,kBAAMoD,EAAgBnP,EAAMmE,IACrC6H,SAAUgC,EACVlC,MAAO,CAAE0E,UAAY5B,OAA6CxL,EAAtB,qBAC5C6I,SAAUA,EAAS9H,KAEnBA,EAAQnD,EAAMb,QAAQ,6B,kDuBpPvC4S,GAA0B,WAAO,IAAD,EAYvChJ,KAVFlK,EAFyC,EAEzCA,MACAmT,EAHyC,EAGzCA,SACAC,EAJyC,EAIzCA,WACAC,EALyC,EAKzCA,WACAC,EANyC,EAMzCA,SACAC,EAPyC,EAOzCA,SACAC,EARyC,EAQzCA,YACA3D,EATyC,EASzCA,MACA4D,EAVyC,EAUzCA,SACAC,EAXyC,EAWzCA,eAXyC,EAaU7F,mBAAS6F,GAbnB,mBAapCC,EAboC,KAafC,EAbe,KAcpCrH,EAAQC,cAARD,KACDsH,EAAc,SAACrX,GACnBqN,QAAQgG,MAAM,gBACd,IACE4D,ErBsIqB,SAAC5D,EAActD,GAA2C,IAAD,EACxCjK,KAAKsE,MAAMiJ,EAAMiE,SAAnD3R,EAD0E,EAC1EA,WAAYC,EAD8D,EAC9DA,OAAQC,EADsD,EACtDA,UAQ5B,OAPA6B,OAAOC,QAAP,OAAgB9B,QAAhB,IAAgBA,IAAa,IAA0CN,SAAQ,YAAyB,IAAD,mBAAtBgS,EAAsB,KAAbC,EAAa,KAEnG5R,EAAO2R,GADc,kBAAZC,EACSzH,EAAKyH,GAELA,EAAQpP,KAAI,SAAAqP,GAAG,OAAI1H,EAAK0H,MAAMC,KAAK,SAGlDC,YAAQ5H,EAAKpK,GAAN,eAAkCC,IqB/InCgS,CAAY5X,EAAG+P,IACxB,SACAkH,EAASjX,EAAEsX,WAGTtF,EAASxO,EAAMxC,OAAS6V,GAAcC,EAAS5R,SAAS1B,EAAMsD,QAAQtD,EAAMxC,OAC5E6W,EAAc,yCAAG,WAAOnO,GAAP,UAAAwB,EAAA,kEAEf1H,EAAMxC,OAAS6V,EAFA,gCAGXF,EAASjN,GAAQyJ,MAAK,kBAAM8D,EAAS,OAH1B,kCAIRH,EAAS5R,SAAS1B,EAAMsD,QAAQtD,EAAMxC,OAJ9B,iCAKX4V,EAAWpT,EAAMxC,KAAM0I,GAAQyJ,MAAK,kBAAM8D,EAAS,OALxC,qCAOX,IAAIhX,MAAM,eAPC,gEAUnBoX,EAAY,EAAD,IAVQ,+DAAH,sDAcdnN,EAAQ,yCAAG,WAAOX,GAAP,gBAAA2B,EAAA,6DACTxB,EAAqB,CACzB9E,KAAMpE,EAAewJ,UACrBT,WAHa,SAKTsO,EAAenO,GAAQyJ,MAAK,WAC5B2D,EAAShT,OAAS,GACpBkT,GAAY,MAPD,2CAAH,sDAWRc,EAAW,yCAAG,WAAOvO,GAAP,gBAAA2B,EAAA,6DACZxB,EAAqB,CACzB9E,KAAMpE,EAAe6J,aACrBd,WAHgB,SAKZsO,EAAenO,GALH,2CAAH,sDAOXqI,EAAO,yCAAG,6BAAA7G,EAAA,6DACRxB,EAAqB,CACzB9E,KAAMpE,EAAe+J,UAFT,SAIRsN,EAAenO,GAJP,2CAAH,qDAMb6H,qBAAU,WACRC,YAAW,WACT4F,EAAsBF,KACrB,OACF,CAACA,IACJ3F,qBAAU,WACR6F,EAAsBP,KACrB,CAACA,IACJ,IAAM3E,EAAgB6F,mBAAQ,kBrBmHE,SAACvU,GAA+B,IACxD7B,EAA8B6B,EAA9B7B,QAASC,EAAqB4B,EAArB5B,KAAMZ,EAAewC,EAAfxC,KAAMK,EAASmC,EAATnC,KAC7B,IAAImC,EAAMuH,QACR,OAAO,EAET,IAAM9D,EAAOzD,EAAMjC,WAAWP,GAC9B,QAAKY,IAAUqF,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM6C,kBAG5CjC,IAASX,EAAMuD,SACZrC,IAAUqF,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM4C,oBAG5C1B,EACKsF,EAAK/B,SAASzE,EAAM4C,eAEtB4D,EACJvD,QAAO,SAAAC,GAAI,OAAIQ,EAAaR,KAAU/C,EAAWwD,QACjDV,QAAO,SAAAC,GAAI,OAAI/B,GAAOgC,EAAYD,KAAUhD,EAAU8D,UACtDf,QAAO,SAAAC,GAAI,OAAIe,EAAuB,CAACf,GAAOC,EAAYJ,EAAMpC,MAAM,QACtEsC,QAAO,SAAAC,GAAI,OAAKH,EAAMpC,MAAMgH,KAAI,SAAAzE,GAAI,OAAIQ,EAAaR,MAAOuB,SAASf,EAAaR,OAAQG,OAAS,KAEjGlC,IAAUqF,EAAK0B,MAAK,SAAAhF,GAAI,OAAIA,IAASlD,EAAM2C,kBAG5CzB,EACKsF,EAAK/B,SAASzE,EAAM2C,aAEtB6D,EACJvD,QAAO,SAAAC,GAAI,OAAIQ,EAAaR,KAAUQ,EAAaX,EAAMpC,MAAM,OAC/D0C,OAAS,IqBjJsBkU,CAAmBxU,KAAQ,CAACA,IAC5DsO,EAAgBhQ,EAAc0S,aACR,IAAvBhR,EAAMpC,MAAM0C,SACbgO,EAAgBhQ,EAAcoT,YAE7B1R,EAAMuH,cAAmChE,IAAxBoQ,GAA6D,OAAxBA,GAAgC3T,EAAMjC,WAAW4V,GAAqBrT,OAASN,EAAMhC,SAAS2V,KACrJrF,EAAgBhQ,EAAcoR,SAEhC,IAAM+E,EAAgB,yCAAG,WAAO1O,GAAP,UAAA2B,EAAA,yDACpB4G,IAAkBhQ,EAAcoR,QADZ,gCAEf4E,EAAYvO,GAFG,6CAIfW,EAASX,GAJM,2CAAH,sDAOhB0I,EAAS,yCAAG,WAAOtN,GAAP,UAAAuG,EAAA,sEACVyL,EAAS,CACb/R,KAAMpE,EAAeyK,QACrB1B,QAAS,CACP5E,WAEDyO,MAAMiE,GANO,2CAAH,sDAQf,OACE,sBAAK5H,MAAO,CAAEU,cAAe,MAAO3H,MAAO,SAA3C,UACGhF,EAAMuH,cAA0BhE,IAAf8P,GAClB,cAAC,GAAD,CACElS,MAAOnB,EAAMjC,WAAN,OAAiB4V,QAAjB,IAAiBA,IAAuBN,GAC/ChF,cAAeoG,EACfnG,cAAeA,EACfH,KAAMoF,EACNnF,OAAQ,kBAAMoF,GAAY,IAC1BjF,QAASA,EACTC,OAAQA,EACRC,UAAWA,EACXC,cAAeA,IAEjB,qBAAKzC,MAAO,CAAEyI,UAAW,OAAzB,SACG1U,EAAM/B,KAAKyF,QAAQiR,UAAU/P,KAAI,SAACgQ,EAAGnM,GAAJ,OAAU,8BAAcmM,GAAJnM,QAExD,eAACoM,GAAA,EAAD,CAAQC,KAAgB,KAAVjF,EAAckF,QAAS,kBAAMtB,EAAS,KAAKuB,kBAAgB,oBAAzE,UACE,cAACC,GAAA,EAAD,oBACA,cAACC,GAAA,EAAD,UACE,cAACC,GAAA,EAAD,UACGtF,MAGL,cAACuF,GAAA,EAAD,UACE,cAACvE,GAAA,EAAD,CAAQ3E,QAAS,kBAAMuH,EAAS,KAAKzO,MAAM,UAA3C,4B,2FC3HGqQ,GAAiC,WAAO,IAC3C9I,EAASC,cAATD,KACR,OACE,cAAC+I,GAAA,EAAD,CAAgBC,UAAW9I,KAA3B,SACE,eAAC+I,GAAA,EAAD,CAAOvJ,MAAO,CAAER,MAAO,QAAUxJ,KAAK,QAAtC,UACE,cAACwT,GAAA,EAAD,UACE,eAACC,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,UAAYpJ,EAAKqJ,eACjB,cAACD,GAAA,EAAD,UAAYpJ,EAAKsJ,WACjB,cAACF,GAAA,EAAD,UAAYpJ,EAAKuJ,cAGrB,eAACC,GAAA,EAAD,WACE,eAACL,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,CAAWK,QAAS,EAApB,SAAwBzJ,EAAK0J,OAC7B,cAACN,GAAA,EAAD,oBACA,cAACA,GAAA,EAAD,mBAEF,eAACD,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,oBACA,cAACA,GAAA,EAAD,mBAEF,eAACD,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,iBACA,cAACA,GAAA,EAAD,mBAEF,eAACD,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,CAAWK,QAAS,EAApB,SAAwBzJ,EAAK2J,SAC7B,cAACP,GAAA,EAAD,oBACA,cAACA,GAAA,EAAD,mBAEF,eAACD,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,oBACA,cAACA,GAAA,EAAD,mBAEF,eAACD,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,gBACA,cAACA,GAAA,EAAD,4BCzBCQ,GAA6C,WAAO,IAAD,EACtCtI,oBAAS,GAD6B,mBACvDiH,EADuD,KACjDsB,EADiD,KAEtD7J,EAASC,cAATD,KACR,OACE,sBAAKN,MAAO,CAAEa,SAAU,QAAS2D,KAAM,EAAGD,OAAQ,GAAlD,UACE,cAAC6F,GAAA,EAAD,CAAYnK,QAAS,kBAAMkK,GAAQ,IAAnC,SACE,cAAC,KAAD,MAEF,eAACvB,GAAA,EAAD,CAAQC,KAAMA,EAAMC,QAAS,kBAAMqB,GAAQ,IAAQpB,kBAAgB,oBAAnE,UACE,cAACC,GAAA,EAAD,UAAc1I,EAAK+J,cACnB,eAACpB,GAAA,EAAD,WACE,cAAC,GAAD,IACA,cAACC,GAAA,EAAD,UACG5I,EAAKgK,qBAGV,cAACnB,GAAA,EAAD,UACE,cAACvE,GAAA,EAAD,CAAQ3E,QAAS,kBAAMkK,GAAQ,IAAQpR,MAAM,UAA7C,SACGuH,EAAKiK,iBCxBLC,GAAkC,WAAO,IAAD,EACXvM,KAAhClK,EAD2C,EAC3CA,MAAOqT,EADoC,EACpCA,WAAYF,EADwB,EACxBA,SADwB,EAELtF,mBAAuB,MAFlB,mBAE5C6I,EAF4C,KAE3BC,EAF2B,OAGH9I,oBAAS,GAHN,mBAG5C+I,EAH4C,KAG1BC,EAH0B,OAILhJ,oBAAS,GAJJ,mBAI5CiJ,EAJ4C,KAI3BC,EAJ2B,KAK3CxK,EAASC,cAATD,KACRwB,qBAAU,WACRgJ,GAAmB,GACnB/I,YAAW,WACT6I,GAAoB,KACnB,GACH7I,YAAW,WACT2I,EAAmB3W,EAAMpC,OACzBiZ,GAAoB,GACpBE,GAAmB,KAClB,OACF,CAAC/W,EAAM9B,WAAY8B,EAAMpC,QAC5B,IAKMoZ,EAAK,yCAAG,uBAAAtP,EAAA,sEACNyL,EAAS,CACb/R,KAAMpE,EAAesK,MACpBsI,MAAM/F,QAAQgG,OAHL,2CAAH,qDAKLoH,EAAU,WACd,GAAIjX,EAAMuH,QAAS,CACjB,GAAqB,OAAjBvH,EAAMgE,OAAiB,CACzB,IAAMX,EAASrD,EAAMsD,QAAQtD,EAAMgE,QACnC,OAAOmQ,YAAQ5H,EAAK2K,eAAgB,CAAE7T,WAExC,IAAMA,EAASrD,EAAMsD,QAAQtD,EAAMxC,MACnC,GAAIwC,EAAMjC,WAAWiC,EAAMxC,MAAM8C,OAASN,EAAMhC,SAASgC,EAAMxC,MAC7D,OAAO2W,YAAQ5H,EAAK4K,gCAAiC,CAAE9T,SAAQtE,UAAU,GAAD,OAAKiB,EAAMhC,SAASgC,EAAMxC,SAEpG,GAA2B,IAAvBwC,EAAMpC,MAAM0C,OACd,OAAO6T,YAAQ5H,EAAK6K,4BAA6B,CAAE/T,WAC7C,IAAD,EACCxF,EAAO0O,EAAI,UAACvM,EAAMnC,YAAP,QAAeX,EAAMsD,MACtC,OAAO2T,YAAQ5H,EAAK8K,8BAA+B,CAAEhU,SAAQxF,UAdnD,GAmBViY,EAASvB,mBAAQ,2BAASxU,EAAcC,MAAU,CAACA,IACnDsX,EAAQ,WACZ,GAAItX,EAAMuH,QAAS,CACjB,GAAIvH,EAAMjC,WAAWiC,EAAMxC,MAAM8C,OAASN,EAAMhC,SAASgC,EAAMxC,MAC7D,OAAO2W,YAAQ5H,EAAKgL,sBAAuB,CAAElU,OAAQrD,EAAMsD,QAAQtD,EAAMxC,MAAOsY,WAElF,GAAqB,OAAjB9V,EAAMgE,OACR,OAAOuI,EAAKiL,SAEd,GAAIxX,EAAM5B,KACR,OAAOmO,EAAKkL,SAEd,GAAIzX,EAAM7B,QACR,OAAOoO,EAAKmL,aAZJ,GAiBd,OACG1X,EAAMuH,QAIH,sBACA0E,MAAO,CACL0L,gBAAiB,QACjB7K,SAAU,QACVM,IAAK,EACLqD,KAAM,EACNpD,MAAO,EACPmD,OAAQ,EACRxL,MAAO,QACP4S,UAAW5X,EAAM5B,KAAO,+BAA4BmF,EACpDuI,WAAY,+BAVd,UAYA,qBAAKG,MAAO,CAAE2E,QAAS,OAAQ8B,eAAgB,eAAgBxF,OAAQ,QAAvE,SAEI,IAAIrK,MAAM7C,EAAMsD,QAAQhD,QAAQ+D,KAAK,GAAGO,KAAI,SAACF,EAAG+D,GAAJ,OAAaA,GAAC,OAAI4K,QAAJ,IAAIA,IAAc,GAlE7CrT,EAAMhC,SAASsC,QAAUN,EAAMhC,SAASsC,UAkEUJ,QAAO,SAAAnD,GAAE,OAAIA,KAAE,OAAMsW,QAAN,IAAMA,IAAc,MAAIzO,KAAI,SAAA7H,GAAE,OAC5H,sBAAKkP,MAAO,CAAE4L,OAAO,SAAD,OAAW7X,EAAMxC,OAAST,EAAK,MAAQ,cAAvC,QAA4DyO,QAAS,aAAzF,UACE,8BACGxL,EAAMsD,QAAQvG,KAEjB,uCACOiD,EAAMhC,SAASjB,cAOT,OAApB2Z,GACD,qBAAKzK,MAAK,aAAIa,SAAU,YA/Ef,CACbM,IAAK,OACLqD,KAAM,SA6EF,SACE,sBAAKxE,MAAO,CAAE0E,UAAW,wBAAyB5D,UAAW,UAA7D,UACGuK,GAAQ,6BAAKA,IACd,6BAAKL,SACa1T,IAAjBvD,EAAMgE,QAAyC,OAAjBhE,EAAMgE,QAAmB,8BACtD,cAAC6M,GAAA,EAAD,CAAQC,QAAQ,YAAY9L,MAAM,UAAUkH,QAAS8K,EAArD,SAA6DzK,EAAKyK,UAEpE,+BAAKhX,EAAMnC,MAAN,UAAiB0O,EAAKvM,EAAMnC,MAA5B,MAAuCsW,YAAQ5H,EAAKuL,eAAgB,CAAEhC,cAC3E,qBAAK7J,MAAO,CACV2E,QAAS,OACT8B,eAAgB,SAChB9E,SAAU,qBACV+E,SAAU,OACVoF,YAAa,OACbzG,WAAY,OACZ0G,aAAc,QAPhB,SASGtB,EAAgB9R,KAAI,SAAAzE,GAAI,OAAI,qBAAK8L,MAAO,CAAET,QAAS,MAAOkJ,UAAW,QAAzC,SAAmD,cAAC,GAAD,CAAMvU,KAAMA,EAAMgM,UAAQ,gBAK/G2K,GAAwC,OAArB9W,EAAM9B,YAAuB,qBAAK+N,MAAO,CAC3D2E,QAAS,OACT9D,SAAU,WACV2D,KAAM,OACNrD,IAAKwJ,EAAmB,OAAS5W,EAAM9B,WAAWkF,WAAaiQ,EAAa,QAAU,QACtFvH,WAAY,CAAC,MAAO,SAAU,OAAQ,SAASlH,KAAI,SAAAgQ,GAAC,gBAAOA,EAAP,wBAA6BV,KAAK,MALvC,SAO/C,qBAAKjI,MAAO,CAAE0E,UAAW,uBAAwBC,QAAS,QAA1D,SACG5Q,EAAM9B,WAAWiD,MAAMyD,KAAI,SAAAzE,GAAI,OAAI,qBAAK8L,MAAO,CAAET,QAAS,OAAvB,SAAgC,cAAC,GAAD,CAAMrL,KAAMA,EAAMgM,UAAQ,aAGlG,qBAAIF,MAAO,CACTa,SAAU,WACV0D,OAAQ,EACRnD,MAAO,OACPN,UAAW,QACX8K,OAAO,SAAD,OAAW7X,EAAMxC,QAAN,OAAgB6V,QAAhB,IAAgBA,IAAc,GAAK,MAAQ,cAAtD,QACN7H,QAAS,aANX,UAQE,gCACGe,EAAK0L,KADR,KACgBjY,EAAMsD,QAAN,OAAc+P,QAAd,IAAcA,IAAc,MAE5C,uCACOrT,EAAMhC,SAAN,OAAeqV,QAAf,IAAeA,IAAc,MAEpC,gCACG9G,EAAK5O,SADR,KACoBqC,EAAMrC,SAAS2C,aAGrC,cAAC,GAAD,OAlFA,qBACA2L,MAAO,CAAE0L,gBAAiB,QAAS7K,SAAU,QAASM,IAAK,EAAGqD,KAAM,EAAGpD,MAAO,EAAGmD,OAAQ,EAAGxL,MAAO,YC1E9FkT,GACX,gCACE,wCACA,uCACA,mJAGA,2OAIA,gFAGA,uCACA,8CACA,+BACE,qFACA,0FAEF,iDACA,+BACE,gEACA,gEACA,kDAEF,6CACA,+BACE,qFACA,2IACA,+BACE,sEACA,+BACE,0EACE,+BACE,qEACA,6DAGJ,4EACE,+BACE,yLAGA,+DAGJ,8MACA,6DACA,uEAGJ,2FACA,kLAIA,+CAAkB,KAAlB,4KACA,+CAAkB,KAAlB,4DAEF,8CACA,cAAC,GAAD,IACA,sIC7DSC,GAAE,2BACVC,IAAYD,IADF,QAEbE,SAAU,SACVH,UAAW,cACXI,iBAAkBJ,IAJL,eAKZhb,EAAMsD,KAAO,iBALD,eAMZtD,EAAMuD,OAAS,mBANH,eAOZtD,EAAU4D,KAAO,QAPL,eAQZ5D,EAAU6D,QAAU,WARR,eASZ7D,EAAU8D,OAAS,UATP,eAUZ9D,EAAUkD,OAAS,UAVP,eAWZlD,EAAU2C,YAAc,eAXZ,eAYZ1C,EAAWwD,KAAO,QAZN,eAaZxD,EAAWoB,MAAQ,SAbP,eAcZpB,EAAWqB,MAAQ,SAdP,eAeZrB,EAAWsB,KAAO,QAfN,eAgBZtB,EAAWuB,KAAO,QAhBN,eAiBZvB,EAAWwB,QAAU,WAjBT,eAkBZxB,EAAWyB,MAAQ,SAlBP,eAmBZzB,EAAW0B,KAAO,QAnBN,eAoBZ7B,EAAM+B,WAAa,cApBP,eAqBZ/B,EAAMgC,WAAa,cArBP,eAsBZhC,EAAMiC,UAAY,aAtBN,eAuBZjC,EAAMkC,UAAY,aAvBN,eAwBZlC,EAAMmC,aAAe,gBAxBT,eAyBZnC,EAAMoC,cAAgB,iBAzBV,eA0BZpC,EAAMqC,cAAgB,iBA1BV,eA2BZrC,EAAMsC,aAAe,gBA3BT,eA4BZtC,EAAMuC,aAAe,gBA5BT,eA6BZvC,EAAMwC,gBAAkB,mBA7BZ,eA8BZxC,EAAMyC,aAAe,gBA9BT,eA+BZzC,EAAM0C,YAAc,eA/BR,eAgCZ1C,EAAM2C,YAAc,eAhCR,eAiCZ3C,EAAM4C,cAAgB,iBAjCV,eAkCZ5C,EAAM6C,YAAc,eAlCR,0BAmCH,aAnCG,0BAoCH,8DApCG,4BAqCD,2DArCC,gCAsCG,uBAtCH,iDAuCoB,6CAvCpB,6CAwCgB,oCAxChB,+CAyCkB,sCAzClB,gCA0CG,8BA1CH,uBA2CN,SA3CM,0BA4CH,aA5CG,6BA6CA,iBA7CA,yBA8CJ,YA9CI,4CA+Ce,sCA/Cf,yBAgDJ,WAhDI,wCAiDW,4BAjDX,0CAkDa,8BAlDb,uBAmDN,SAnDM,2JAqDe,uCArDf,sCAsDS,oDAtDT,iDAuDoB,mEAvDpB,8CAwDiB,yCAxDjB,sCAyDS,uCAzDT,oDA0DuB,4EA1DvB,8CA2DiB,wDA3DjB,qDA4DwB,iDA5DxB,2DA6D8B,sDA7D9B,qDA8DwB,gEA9DxB,yEA+D4C,sGA/D5C,qCAgEQ,8BAhER,6CAiEgB,wCAjEhB,0DAkE6B,kDAlE7B,0DAmE6B,kDAnE7B,6BAoEA,eApEA,0CAqEa,kCArEb,8BAsEC,iBAtED,0BAuEH,sCAvEG,wBAwEL,UAxEK,iCAyEI,sGAzEJ,6BA0EA,gBA1EA,uBA2EN,SA3EM,kCA4EK,uBA5EL,uCA6EU,4CA7EV,KCDFoY,GACX,gCACE,4EACA,8CACA,kUAIA,gcAIA,kIAGA,0DACA,qDACA,+BACE,6JACA,gKAEF,qDACA,+BACE,qLACA,iJACA,+GAEF,8CACA,+BACE,0GACA,8OACA,+BACE,mFACA,+BACE,8FACE,+BACE,oIACA,kFAGJ,8FACE,+BACE,oVAEA,kFAGJ,4UACA,wFACA,4EAGJ,8IACA,0VAGA,4WACA,sOAEF,oDACA,cAAC,GAAD,IACA,8LC7DSK,GAAQ,CACnBJ,MACAK,GCDa,2BACVJ,IAAYI,IADF,QAEbH,SAAU,6CACVH,UAAW,eACXI,iBAAkBJ,IAJL,eAKZhb,EAAMsD,KAAO,4BALD,eAMZtD,EAAMuD,OAAS,4BANH,eAOZtD,EAAU4D,KAAO,gBAPL,eAQZ5D,EAAU6D,QAAU,gBARR,eASZ7D,EAAU8D,OAAS,4BATP,eAUZ9D,EAAUkD,OAAS,gBAVP,eAWZlD,EAAU2C,YAAc,kCAXZ,eAYZ1C,EAAWwD,KAAO,sBAZN,eAaZxD,EAAWoB,MAAQ,gBAbP,eAcZpB,EAAWqB,MAAQ,gBAdP,eAeZrB,EAAWsB,KAAO,gBAfN,eAgBZtB,EAAWuB,KAAO,gBAhBN,eAiBZvB,EAAWwB,QAAU,gBAjBT,eAkBZxB,EAAWyB,MAAQ,gBAlBP,eAmBZzB,EAAW0B,KAAO,gBAnBN,eAoBZ7B,EAAM+B,WAAa,4BApBP,eAqBZ/B,EAAMgC,WAAa,4BArBP,eAsBZhC,EAAMiC,UAAY,4BAtBN,eAuBZjC,EAAMkC,UAAY,4BAvBN,eAwBZlC,EAAMmC,aAAe,4BAxBT,eAyBZnC,EAAMoC,cAAgB,4BAzBV,eA0BZpC,EAAMqC,cAAgB,4BA1BV,eA2BZrC,EAAMsC,aAAe,4BA3BT,eA4BZtC,EAAMuC,aAAe,4BA5BT,eA6BZvC,EAAMwC,gBAAkB,4BA7BZ,eA8BZxC,EAAMyC,aAAe,wCA9BT,eA+BZzC,EAAM0C,YAAc,wCA/BR,eAgCZ1C,EAAM2C,YAAc,4BAhCR,eAiCZ3C,EAAM4C,cAAgB,4BAjCV,eAkCZ5C,EAAM6C,YAAc,kCAlCR,0BAmCH,4BAnCG,0BAoCH,uFApCG,4BAqCD,+HArCC,gCAsCG,gCAtCH,iDAuCoB,mDAvCpB,6CAwCgB,sCAxChB,+CAyCkB,kCAzClB,gCA0CG,oDA1CH,uBA2CN,4BA3CM,0BA4CH,sBA5CG,6BA6CA,+CA7CA,yBA8CJ,wCA9CI,4CA+Ce,iEA/Cf,yBAgDJ,gBAhDI,wCAiDW,wCAjDX,0CAkDa,wCAlDb,uBAmDN,gBAnDM,mLAqDe,kCArDf,sCAsDS,wFAtDT,iDAuDoB,wFAvDpB,8CAwDiB,sEAxDjB,sCAyDS,sEAzDT,oDA0DuB,8FA1DvB,8CA2DiB,+FA3DjB,qDA4DwB,4EA5DxB,2DA6D8B,4EA7D9B,qDA8DwB,mEA9DxB,yEA+D4C,kKA/D5C,qCAgEQ,0CAhER,6CAiEgB,8EAjEhB,0DAkE6B,4EAlE7B,0DAmE6B,4EAnE7B,6BAoEA,wCApEA,0CAqEa,qCArEb,8BAsEC,4BAtED,0BAuEH,8EAvEG,wBAwEL,gBAxEK,iCAyEI,8JAzEJ,6BA0EA,sBA1EA,uBA2EN,gBA3EM,kCA4EK,oDA5EL,uCA6EU,wEA7EV,MCwBA2Y,GAnBgBC,YAAUC,YAAgB,CAAEJ,UAAlBI,C3BAV,SAACC,GAC9B,IAAMC,EAAqC,SAAAC,GACzC,IAAM3O,EAAU4O,YAAoB9S,EAAa,IAAI5I,OAAakG,EAAW,UACtEyV,EAA2B7O,EAA3B6O,MAAOhZ,EAAoBmK,EAApBnK,MAAMoT,EAAcjJ,EAAdiJ,WAcpB,OAbArF,qBAAU,WACR,QAAiBxK,IAAbuF,IAA0BkQ,EAAMtX,SAAS1B,EAAMsD,QAAQtD,EAAMxC,QAAUwC,EAAMuH,SAA4B,OAAjBvH,EAAMgE,OAAiB,CACjH,IAKMiV,EAAI/H,OAAOlD,YALN,WACT,IAAM9H,EAAS4C,GAAS9I,EAAOA,EAAMxC,MAErC4V,EAAWpT,EAAMxC,KAAM0I,GAAQ0J,MAAM/F,QAAQgG,SAEf,KAChC,OAAO,WACLqB,OAAOgI,aAAaD,OAGvB,CAAC7F,EAAY4F,EAAOhZ,IAErB,cAACgK,GAAemP,SAAhB,CAAyBC,MAAOjP,EAAhC,SACE,cAACyO,EAAD,eAAeE,OAKrB,OADAD,EAAgBQ,YAAc,kBACvBR,E2BxB2DS,EAAgB,WAClF,IAAMnP,EAAUD,KACRqC,EAASC,cAATD,KACR,OACE,eAAC,IAAD,CAAiBgN,aAAcpP,EAAQoP,aAAcC,SAAU,EAAC,GAAO,GAAO,GAAO/C,aAAc,cAAC,GAAD,IAAnG,UACE,cAAC,IAAD,2BAAUtM,GAAV,IAAmBkO,SAAU9L,EAAK8L,SAAlC,SACE,cAACnD,GAAA,EAAD,UACG3I,EAAK+L,sBAGV,cAAC,IAAD,eAAUnO,IACV,cAAC,GAAD,IACA,qBAAK8B,MAAO,CAAEa,SAAU,QAASM,IAAK,EAAGC,MAAO,EAAGqD,OAAQ,KAA3D,SACE,cAAC,IAAD,cCRO+I,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBhK,MAAK,YAAkD,IAA/CiK,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCHdO,IAASC,OACP,cAAC,GAAD,IACAC,SAASC,eAAe,SAM1BX,O","file":"static/js/main.aa2d8cb2.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 207;","// GameAction.ts\n\nimport { GameActionTypes, GenericBoardGameAction } from 'gamenet'\nimport { ICard, IDeck, IMode } from './types'\nimport { NetworkAction } from 'smnet'\n\nexport enum GameActionType {\n  PLAY_CARD,\n  END,\n  DISCARD_CARD,\n  TAKE_HIT,\n  REORDER\n}\n\nexport interface PlayCardPayload {\n  cards: ICard[]\n  mode?: IMode\n}\n\nexport type GameAction = (({\n  type: GameActionType.DISCARD_CARD\n  payload: PlayCardPayload\n} | {\n  type: GameActionType.PLAY_CARD\n  payload: PlayCardPayload\n} | {\n  type: GameActionType.END\n} | {\n  type: GameActionType.TAKE_HIT\n}  | {\n  type: GameActionType.REORDER\n  payload: {cards: IDeck}\n} | {\n  type: GameActionTypes\n  payload: never\n}) & NetworkAction) | GenericBoardGameAction\n","import { GameState } from './GameState'\nimport { PlayCardPayload } from './GameAction'\n\nexport enum ICard {\n  EARTH_MAGE = 'earth_mage',\n  WATER_MAGE = 'water_mage',\n  FIRE_MAGE = 'fire_mage',\n  WIND_MAGE = 'wind_mage',\n  THUNDER_MAGE = 'thunder_mage',\n  EARTH_MISSILE = 'earth_missile',\n  WATER_MISSILE = 'water_missile',\n  FIRE_MISSILE = 'fire_missile',\n  WIND_MISSILE = 'wind_missile',\n  THUNDER_MISSILE = 'thunder_missile',\n  LIGHT_MAGILE = 'light_magile',\n  DARK_MAGILE = 'dark_magile',\n  HOMO_IGNITE = 'homo_ignite',\n  HETERO_IGNITE = 'hetero_ignite',\n  ANGEL_GUARD = 'angel_guard'\n}\n\nexport enum IMode {\n  HOMO='homo',\n  HETERO='hetero'\n}\n\nexport type IDeck = ICard[]\n\nexport type IStateMapper = (prevState: GameState) => GameState\n\nexport type IsCard = (card: ICard) => boolean\n\nexport type IPlayCard = (payload: PlayCardPayload, playerId: number) => IStateMapper\n\nexport enum ICardType {\n  MAGE='mage',\n  MISSILE='missile',\n  MAGILE='magile',\n  IGNITE='ignite',\n  ANGEL_GUARD='angel_guard'\n}\n\nexport enum ICardColor {\n  NONE= 'none',\n  EARTH= 'earth',\n  WATER= 'water',\n  FIRE= 'fire',\n  WIND= 'wind',\n  THUNDER= 'thunder',\n  LIGHT= 'light',\n  DARK= 'dark'\n}\n\nexport const allColors: ICardColor[] = [\n  ICardColor.EARTH,\n  ICardColor.WATER,\n  ICardColor.FIRE,\n  ICardColor.WIND,\n  ICardColor.THUNDER,\n  ICardColor.LIGHT,\n  ICardColor.DARK,\n]\n","// Poker99State.ts\n\nimport { GenericBoardGameState } from 'gamenet'\nimport { IDeck, IMode } from './types'\nimport { PlayCardPayload } from './GameAction'\n\nexport class GameState extends GenericBoardGameState {\n  [key: string]: unknown | undefined\n\n  maxPlayer = 8\n  minPlayer = 2\n  turn = 0\n  direction = 1\n  points = 0\n  drawDeck: IDeck = []\n  stage: IDeck = []\n  mode: IMode | null = null\n  trashDeck: IDeck = []\n  playerDeck: IDeck[] = []\n  playerHp: number[] = []\n  logs: string[] = []\n  lastAction: PlayCardPayload & { playerId: number } | null = null\n  ignited = false\n  duel = false\n}\n","import React, { FunctionComponent, ReactNode, useEffect, useReducer, useState } from 'react'\nimport { ICard, IDeck, IMode } from '../types'\nimport { Card } from './Card'\nimport { Button } from '@material-ui/core'\nimport { Delete, Flag, PlayArrow, Visibility } from '@material-ui/icons'\nimport { PlayCardPayload } from '../GameAction'\nimport { Equal, NotEqual } from 'mdi-material-ui'\nimport { useGamenetI18n } from 'gamenet-material'\nimport { DragDropContext, Draggable, Droppable, DropResult } from 'react-beautiful-dnd'\nimport { reorderInPlace } from '../utils'\n\nconst DURATION = 0.3\n\nconst PlaceHolder: FunctionComponent<{ maxWidth: string, style?: Record<string, unknown> }> = ({ maxWidth, style }) => {\n  const [width, setWidth] = useState(maxWidth)\n  useEffect(() => {\n    setTimeout(() => {\n      setWidth('0')\n    }, 1)\n  }, [])\n  return (\n    <div style={{\n      maxWidth: width,\n      minWidth: width,\n      transition: `min-width ${DURATION}s ease-in-out`,\n      position: 'relative',\n      ...style\n    }}/>\n  )\n}\n\nexport enum ChooseCardFor {\n  FIRST_PLAY,\n  RESPOND_PLAY,\n  DISCARD\n}\n\nexport const Deck: FunctionComponent<{\n  cards: ICard[], hide: boolean, reveal: () => void, onCardsChoose: (payload: PlayCardPayload) => Promise<void>, chooseCardFor: ChooseCardFor, takeHit: () => Promise<void>, myTurn?: boolean, onReorder: (cards: IDeck) => Promise<void>, ableToRespond: boolean\n}> = ({ cards, hide, reveal, onCardsChoose, chooseCardFor, takeHit, myTurn, onReorder, ableToRespond }) => {\n  const [playedIndices, setPlayedIndices] = useState<number[]>([])\n  const [hovering, setHovering] = useState<number | null>(null)\n  const [playGetCardAnimation, setPlayGetCardAnimation] = useState(false)\n  const [discardingAnimation, setDiscardingAnimation] = useState(false)\n  const { i18n } = useGamenetI18n()\n  const [selected, dispatchSelected] = useReducer<(prev: boolean[], action: { type: string, payload?: number | boolean[] }) => boolean[]>((prev, {\n    type,\n    payload\n  }) => {\n    switch (type) {\n      case 'add':\n        if (payload !== undefined && !Array.isArray(payload)) {\n          prev[payload] = true\n        }\n        return [...prev]\n      case 'delete':\n        if (payload !== undefined && !Array.isArray(payload)) {\n          prev[payload] = false\n        }\n        return [...prev]\n      case 'clear':\n        return []\n      case 'override':\n        if (Array.isArray(payload)) {\n          return [...payload]\n        }\n        return prev\n      default:\n        return prev\n    }\n  }, [])\n  const handleCardClick = async (card: ICard, index: number) => {\n    if (selected[index]) {\n      dispatchSelected({ type: 'delete', payload: index })\n    } else {\n      dispatchSelected({ type: 'add', payload: index })\n    }\n  }\n  const handlePlayCards = (param: unknown) => {\n    const mode = param === IMode.HOMO || param === IMode.HETERO ? param : undefined\n    const laterSetDiscardingAnimation = chooseCardFor === ChooseCardFor.DISCARD\n    onCardsChoose({ cards: cards.filter((_, k) => selected[k]), mode })\n      .then(() => {\n        setDiscardingAnimation(laterSetDiscardingAnimation)\n        setHovering(null)\n        setPlayedIndices(selected.map((b, k: number) => [b, k]).filter(([b]) => b).map(([_, k]) => k as number))\n        dispatchSelected({ type: 'clear' })\n        setTimeout(() => {\n          setPlayGetCardAnimation(true)\n        }, 1)\n        setTimeout(() => {\n          setPlayGetCardAnimation(false)\n          setPlayedIndices([])\n          setDiscardingAnimation(false)\n        }, 500)\n      })\n      .catch(e => {\n        console.error(e)\n      })\n  }\n  const getPlayedCards = () => {\n    const cardsToRender = []\n    let j = 0\n    for (let i = 0; i < cards.length; i++) {\n      if (playedIndices.includes(i)) {\n        cardsToRender.push(null)\n      } else {\n        cardsToRender.push(cards[j])\n        j++\n      }\n    }\n    return discardingAnimation ? [...cardsToRender, ...cards.slice(j)] : cardsToRender\n  }\n  const onDragEnd = (result: DropResult) => {\n    const from = result.source.index\n    const to = result.destination?.index\n    if (from !== undefined && to !== undefined) {\n      reorderInPlace(cards, from, to)\n      reorderInPlace(selected, from, to)\n      dispatchSelected({\n        type: 'override',\n        payload: selected\n      })\n      onReorder(cards).catch(console.error)\n    }\n  }\n  const withMaxWidth = (children: ReactNode, index: number, noPad = false) => (\n    <div\n      style={{\n        padding: noPad ? 0 : '8px',\n        maxWidth: `calc(100vw / ${cards.length + 2})`,\n        transition: `max-width ${DURATION / 3}s ease-in-out`\n      }}\n      onMouseEnter={() => setHovering(index)}\n      onTouchStart={() => setHovering(index)}\n      onMouseLeave={() => setHovering(null)}\n      onTouchEnd={() => setHovering(null)}>\n      {children}\n    </div>\n  )\n  return <div style={{\n    position: 'absolute',\n    bottom: hide ? '-200px' : '-100px',\n    left: 0,\n    right: 0,\n    zIndex: 1,\n    transition: `bottom 0.3s ease-in-out`,\n    pointerEvents: 'none'\n  }}>\n    <div style={{\n      textAlign: 'center',\n      transform: 'translateY(-80px)',\n      margin: 'auto',\n      display: 'block',\n      pointerEvents: 'all'\n    }}>\n      {myTurn ? <>\n        {hide && <Button variant='contained' onClick={reveal}>\n          <Visibility/>\n        </Button>}\n        {!hide && chooseCardFor === ChooseCardFor.RESPOND_PLAY && <>\n          <Button variant='contained'\n                  title={i18n.takeHit}\n                  color='secondary'\n                  onClick={() => (!ableToRespond || window.confirm(i18n.areYouSureYouWantToTakeHit)) && takeHit().catch(console.error)}\n          >\n            <Flag/>\n          </Button>\n          <Button style={{ marginLeft: '8px' }} variant='contained'\n                  title={i18n.respond}\n                  color='primary'\n                  onClick={handlePlayCards}\n          >\n            <PlayArrow/>\n          </Button>\n          {!ableToRespond && <div style={{marginLeft: '8px'}}>({i18n.notAbleToRespond})</div>}\n        </>}\n        {!hide && chooseCardFor === ChooseCardFor.FIRST_PLAY && <>\n          <Button variant='contained'\n                  title={i18n.initializeHomoTransfer}\n                  color='primary'\n                  onClick={() => handlePlayCards(IMode.HOMO)}\n          >\n            <Equal/>\n          </Button>\n          <Button style={{ marginLeft: '8px' }} variant='contained'\n                  title={i18n.initializeHeteroTransfer}\n                  color='primary'\n                  onClick={() => handlePlayCards(IMode.HETERO)}\n          >\n            <NotEqual/>\n          </Button>\n        </>}\n        {!hide && chooseCardFor === ChooseCardFor.DISCARD && <>\n          <Button variant='contained'\n                  color='secondary'\n                  title={i18n.trash}\n                  onClick={handlePlayCards}\n          >\n            <Delete/>\n          </Button>\n        </>}\n      </> : i18n.notYourTurn}\n    </div>\n    <DragDropContext onDragEnd={onDragEnd}>\n      <Droppable droppableId='droppable' direction='horizontal'>\n        {(provided, snapshot) => (\n          <div ref={provided.innerRef} {...provided.droppableProps}>\n            <div style={{ display: 'flex', justifyContent: 'center', flexWrap: 'nowrap' }}>\n              {\n                getPlayedCards().map((card, index) => (\n                  <Draggable index={index} draggableId={index.toString()}>\n                    {(provided, snapshot) => (\n                      <div ref={provided.innerRef}\n                           {...provided.draggableProps}\n                           {...provided.dragHandleProps}>{\n                        card === null\n                          ? <PlaceHolder key={index} maxWidth={`calc(100vw / ${cards.length + 2} + 16px)`}/>\n                          : withMaxWidth(<Card\n                            card={card}\n                            onClick={() => !snapshot.isDragging && handleCardClick(card, index)}\n                            disabled={hide}\n                            style={{ transform: !snapshot.isDragging && (hovering === index || selected[index]) ? 'translateY(-30%)' : undefined }}\n                            selected={selected[index]}\n                            isDelete={chooseCardFor === ChooseCardFor.DISCARD}\n                          />, index)\n\n                      }</div>)}\n                  </Draggable>))\n              }\n              {provided.placeholder}\n              {playedIndices.length > 0 && !discardingAnimation &&\n              <Draggable index={cards.length + 1} draggableId='incoming'>\n                {(provided, snapshot) => (\n                  <div ref={provided.innerRef}\n                       {...provided.draggableProps}\n                       {...provided.dragHandleProps}>\n                    <div style={{\n                      maxWidth: playGetCardAnimation ? `calc((100vw / ${cards.length + 2} + 16px) * ${playedIndices.length})` : '0',\n                      transition: `max-width ${DURATION}s ease-in-out`,\n                      display: 'flex',\n                      flexWrap: 'nowrap'\n                    }}>\n                      {\n                        cards.slice(cards.length - playedIndices.length).map((card, index) => (\n                          withMaxWidth(\n                            <Card\n                              card={card}\n                              onClick={() => handleCardClick(card, index)}\n                              disabled={hide}\n                              style={{ transform: !playGetCardAnimation ? 'translateX(100vw)' : undefined }}\n                              selected={selected[index]}\n                            />\n                            , index + cards.length, false\n                          )\n                        ))\n                      }\n                    </div>\n                  </div>\n                )}\n              </Draggable>\n              }\n            </div>\n          </div>\n\n        )}\n      </Droppable>\n\n    </DragDropContext>\n  </div>\n}\n","import { ICard } from './types'\n\nexport const cardCount = {\n  [ICard.EARTH_MAGE]: 9,\n  [ICard.WATER_MAGE]: 9,\n  [ICard.FIRE_MAGE]: 9,\n  [ICard.WIND_MAGE]: 9,\n  [ICard.THUNDER_MAGE]: 9,\n  [ICard.EARTH_MISSILE]: 9,\n  [ICard.WATER_MISSILE]: 9,\n  [ICard.FIRE_MISSILE]: 9,\n  [ICard.WIND_MISSILE]: 9,\n  [ICard.THUNDER_MISSILE]: 9,\n  [ICard.LIGHT_MAGILE]: 3,\n  [ICard.DARK_MAGILE]: 3,\n  [ICard.HOMO_IGNITE]: 3,\n  [ICard.HETERO_IGNITE]: 3,\n  [ICard.ANGEL_GUARD]: 6\n}\n","import { ICard, ICardColor, ICardType, IMode } from './types'\nimport { GameState } from './GameState'\nimport { i18nSub } from 'gamenet-material'\n\nexport const basicDamage = (count: number, mode: IMode | null): number => {\n  switch (mode) {\n    case IMode.HOMO:\n      switch (count) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n          return 1\n        case 5:\n        case 6:\n        case 7:\n          return 2\n        default:\n          return 3\n      }\n    case IMode.HETERO:\n      switch (count) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n          return 1\n        case 5:\n        case 6:\n          return 2\n        default:\n          return 3\n      }\n    default:\n      return 0\n  }\n}\n\nexport const computeDamage = (state: GameState) => {\n  const igniteCount = state.stage.filter(card => getCardType(card) === ICardType.IGNITE).length\n  const basic = basicDamage(state.stage.filter(card => getCardColor(card) !== ICardColor.NONE).length, state.mode)\n  return basic + Math.max(igniteCount - 1, 0) + (state.duel ? 1 : 0)\n}\n\nexport const getCardType = (card: ICard): ICardType => {\n  switch (card) {\n    case ICard.EARTH_MAGE:\n    case ICard.WATER_MAGE:\n    case ICard.FIRE_MAGE:\n    case ICard.WIND_MAGE:\n    case ICard.THUNDER_MAGE:\n      return ICardType.MAGE\n    case ICard.EARTH_MISSILE:\n    case ICard.WATER_MISSILE:\n    case ICard.FIRE_MISSILE:\n    case ICard.WIND_MISSILE:\n    case ICard.THUNDER_MISSILE:\n      return ICardType.MISSILE\n    case ICard.LIGHT_MAGILE:\n    case ICard.DARK_MAGILE:\n      return ICardType.MAGILE\n    case ICard.HETERO_IGNITE:\n    case ICard.HOMO_IGNITE:\n      return ICardType.IGNITE\n    case ICard.ANGEL_GUARD:\n      return ICardType.ANGEL_GUARD\n  }\n}\n\nexport const areCardsOfTypeOrMagile = (cards: ICard[], type: ICardType): boolean => {\n  return cards.reduce<boolean>((prev, curr) => {\n    const cardType = getCardType(curr)\n    return prev && (cardType === type || cardType === ICardType.MAGILE)\n  }, true)\n}\n\nexport const getCardColor = (card: ICard): ICardColor => {\n  switch (card) {\n    case ICard.EARTH_MAGE:\n    case ICard.EARTH_MISSILE:\n      return ICardColor.EARTH\n    case ICard.WATER_MAGE:\n    case ICard.WATER_MISSILE:\n      return ICardColor.WATER\n    case ICard.FIRE_MAGE:\n    case ICard.FIRE_MISSILE:\n      return ICardColor.FIRE\n    case ICard.WIND_MAGE:\n    case ICard.WIND_MISSILE:\n      return ICardColor.WIND\n    case ICard.THUNDER_MAGE:\n    case ICard.THUNDER_MISSILE:\n      return ICardColor.THUNDER\n    case ICard.LIGHT_MAGILE:\n      return ICardColor.LIGHT\n    case ICard.DARK_MAGILE:\n      return ICardColor.DARK\n    default:\n      return ICardColor.NONE\n  }\n}\n\nexport const isActionCard = (card: ICard) => {\n  return ![ICardType.MISSILE, ICardType.MAGE].includes(getCardType(card))\n}\n\nexport const areCardsOfColor = (cards: ICard[], color: ICardColor): boolean => {\n  return cards.reduce<boolean>((prev, curr) => {\n    return prev && getCardColor(curr) === color\n  }, true)\n}\n\nexport const areCardsOfDifferentColor = (cards: ICard[]): boolean => {\n  const seenColor = new Set()\n  const filteredCards = cards.filter((card) => getCardColor(card) !== ICardColor.NONE)\n  filteredCards.forEach((card) => {\n    seenColor.add(getCardColor(card))\n  })\n  return seenColor.size === filteredCards.length\n}\n\nexport const hasCardColorNone = (cards: ICard[]): boolean => {\n  return !!cards.find((card) => getCardColor(card) === ICardColor.NONE)\n}\n\nexport const canPlayCard = (state: GameState, card: ICard): boolean => {\n  const { mode, duel, ignited } = state\n  if (duel) {\n    if ([ICardType.MAGILE, ICardType.IGNITE, ICardType.ANGEL_GUARD].includes(getCardType(card))) {\n      return false\n    }\n  }\n  if (state.stage.length === 0) {\n    return !isActionCard(card)\n  }\n  if (card === ICard.ANGEL_GUARD) {\n    return true\n  }\n  if (ignited) {\n    if (![ICardType.IGNITE, ICardType.ANGEL_GUARD].includes(getCardType(card))) {\n      return false\n    }\n  }\n  if (mode === IMode.HOMO) {\n    return card === ICard.HOMO_IGNITE || getCardColor(card) === getCardColor(state.stage[0])\n  }\n  if (mode === IMode.HETERO) {\n    return card === ICard.HETERO_IGNITE || (areCardsOfTypeOrMagile([card], getCardType(state.stage[0])) && areCardsOfDifferentColor([...state.stage, card]))\n  }\n  console.warn('canPlayCard EDGECASE!!!', state, card)\n  return false\n}\n\nexport const randInt = (max: number) => {\n  return Math.floor(Math.random() * max)\n}\n\nexport const buildError = (messageKey: string, values?: Record<string, string>, variables?: Record<string, string | string[]>): Error => {\n  return new Error(JSON.stringify({ messageKey, values: values ?? {}, variables }))\n}\n\nexport const decodeError = (error: Error, i18n: Record<string, unknown>): string => {\n  const { messageKey, values, variables } = JSON.parse(error.message)\n  Object.entries((variables ?? {}) as Record<string, string | string[]>).forEach(([varName, i18nKey]) => {\n    if (typeof i18nKey === 'string') {\n      values[varName] = i18n[i18nKey]\n    } else {\n      values[varName] = i18nKey.map(key => i18n[key]).join(', ')\n    }\n  })\n  return i18nSub(i18n[messageKey] as string, { ...values })\n}\n\nexport const arraySameContent = <T>(a: T[], b: T[]): boolean => {\n  if(a === b) return true\n  if(a.length !== b.length) return false\n  return a.reduce<boolean>((flag, element) => flag && a.filter(e => e === element).length === b.filter(e => e === element).length, true)\n}\n\nexport const reorder = <T>(list: T[], startIndex: number, endIndex: number): T[] => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\nexport const reorderInPlace = <T>(list: T[], startIndex: number, endIndex: number): void => {\n  const result = reorder(list, startIndex, endIndex)\n  for(let i = 0; i < result.length; i++) {\n    list[i] = result[i]\n  }\n};\n\nexport const checkAbleToRespond = (state: GameState): boolean => {\n  const { ignited, duel, turn, mode } = state\n  if(!state.started) {\n    return false\n  }\n  const hand = state.playerDeck[turn]\n  if (!duel && !!hand.find(card => card === ICard.ANGEL_GUARD)) {\n    return true\n  }\n  if (mode === IMode.HETERO) {\n    if (!duel && !!hand.find(card => card === ICard.HETERO_IGNITE)) {\n      return true\n    }\n    if (ignited) {\n      return hand.includes(ICard.HETERO_IGNITE)\n    }\n    return hand\n      .filter(card => getCardColor(card) !== ICardColor.NONE)\n      .filter(card => duel ? getCardType(card) !== ICardType.MAGILE : true)\n      .filter(card => areCardsOfTypeOrMagile([card], getCardType(state.stage[0])))\n      .filter(card => !state.stage.map(card => getCardColor(card)).includes(getCardColor(card))).length > 0\n  } else {\n    if (!duel && !!hand.find(card => card === ICard.HOMO_IGNITE)) {\n      return true\n    }\n    if (ignited) {\n      return hand.includes(ICard.HOMO_IGNITE)\n    }\n    return hand\n      .filter(card => getCardColor(card) === getCardColor(state.stage[0]))\n      .length > 0\n  }\n}\n","import { NetworkReducer } from 'smnet'\nimport { GameState } from './GameState'\nimport { GameAction, GameActionType, PlayCardPayload } from './GameAction'\nimport { allColors, ICard, ICardColor, ICardType, IDeck, IMode, IPlayCard, IStateMapper } from './types'\nimport { compose, GameActionTypes, shuffle } from 'gamenet'\nimport { cardCount } from './constants'\nimport {\n  areCardsOfColor,\n  areCardsOfDifferentColor,\n  areCardsOfTypeOrMagile, arraySameContent,\n  buildError,\n  computeDamage,\n  getCardColor,\n  getCardType,\n  hasCardColorNone,\n  isActionCard\n} from './utils'\n\nconst getFullDeck = (): IDeck => {\n  return Object.entries(cardCount).flatMap(([card, count]) => Array(count).fill(card))\n}\n\nconst withDrawCard: (playerId: number) => IStateMapper = playerId => state => {\n  if (state.playerDeck[playerId].length >= state.playerHp[playerId]) {\n    throw buildError('cannotDraw$playerAlreadyHas$countCards', {\n      player: state.players[playerId],\n      count: `${state.playerHp[playerId]}`\n    })\n  }\n  const card = state.drawDeck[0]\n  if (card === undefined) {\n    return withDrawCard(playerId)({ ...state, drawDeck: shuffle(state.trashDeck), trashDeck: [] })\n  } else {\n    const hand = [...state.playerDeck[playerId], card]\n    const playerDeck = [...state.playerDeck]\n    playerDeck[playerId] = hand\n    if (hand.length < state.playerHp[playerId]) {\n      return withDrawCard(playerId)({ ...state, playerDeck, drawDeck: state.drawDeck.slice(1) })\n    } else {\n      return { ...state, playerDeck, drawDeck: state.drawDeck.slice(1) }\n    }\n  }\n}\n\nconst withEnsureDuelNotFunctionCard: (playerId: number) => IStateMapper = playerId => state => {\n  if (state.duel) {\n    const hand = state.playerDeck[playerId]\n    if (hand.filter(isActionCard).length === hand.length)\n      return compose(\n        withEnsureDuelNotFunctionCard(playerId),\n        withDrawCard(playerId),\n        withDiscardCard({ cards: hand }, playerId)\n      )(state)\n  }\n  return state\n}\n\nconst withInitGame: IStateMapper = (prevState: GameState) => {\n  prevState = {\n    ...prevState,\n    turn: 0,\n    direction: 1,\n    points: 0,\n    drawDeck: [],\n    stage: [],\n    mode: null,\n    trashDeck: [],\n    playerDeck: [],\n    playerHp: [],\n    logs: [],\n    lastAction: null,\n    ignited: false,\n    duel: false,\n    winner: null\n  }\n  const fullDeck = getFullDeck()\n  prevState.drawDeck = shuffle(fullDeck)\n  for (let id = 0; id < prevState.players.length; id++) {\n    prevState.playerDeck[id] = []\n    prevState.playerHp[id] = 7\n    prevState = withDrawCard(id)(prevState)\n  }\n  return { ...prevState }\n}\n\nconst withDiscardCard: IPlayCard = ({ cards }, playerId) => state => {\n  const trashDeck = [...state.trashDeck, ...cards]\n  const hand = [...state.playerDeck[playerId]]\n  cards.forEach((card) => {\n    const index = hand.indexOf(card)\n    if (index === -1) {\n      throw buildError('$playerDoesNotOwnCard$card', { player: state.players[playerId] }, { card })\n    }\n    hand.splice(index, 1)\n  })\n  const playerDeck = [...state.playerDeck]\n  playerDeck[playerId] = hand\n  return { ...state, trashDeck, playerDeck }\n}\n\nconst withPutToPlayed: IPlayCard = ({ cards }) => (state) => {\n  return { ...state, stage: [...state.stage, ...cards] }\n}\n\nconst withCardNumberValidation: IPlayCard = (_, playerId) => (state) => {\n  if (state.playerDeck[playerId].length > state.playerHp[playerId]) {\n    throw buildError('playerCardMoreThanHp')\n  }\n  return state\n}\n\nconst withCardTypeValidation: IPlayCard = ({ cards }, playerId) => state => {\n  if (cards.length === 3) {\n    if (cards.map(card => getCardColor(card)).includes(ICardColor.NONE)) {\n      throw buildError('cannotMixIgniteAngelWithMagiles')\n    }\n    if (state.duel) {\n      if (cards.map(card => getCardType(card)).includes(ICardType.MAGILE)) {\n        throw buildError('cannotPlayFunctionDuringDuel')\n      }\n    }\n  } else if (cards.length === 1) {\n    if (state.duel) {\n      const cardType = getCardType(cards[0])\n      if ([ICardType.MAGILE, ICardType.IGNITE, ICardType.ANGEL_GUARD].includes(cardType)) {\n        throw buildError('cannotPlayFunctionDuringDuel')\n      }\n    }\n  } else {\n    throw buildError('canPlayOnly1Or3Cards')\n  }\n  return state\n}\n\nconst withFirstPlayValidation: IPlayCard = ({ cards, mode }, playerId) => (state) => {\n  if (state.stage.length === 0) {\n    if (mode === null || mode === undefined) {\n      throw buildError('specifyHomoOrHeteroAtFirstTransfer')\n    }\n    if (mode === IMode.HOMO && state.playerHp[(playerId + 1) % state.players.length] === 1) {\n      throw buildError('canOnlyDoHeteroWhenNextIs1hp')\n    }\n    if (cards.length !== 1) {\n      throw buildError('canOnlyPlay1CardWhenAtFirstTransfer')\n    }\n    if (getCardType(cards[0]) !== ICardType.MAGE && getCardType(cards[0]) !== ICardType.MISSILE) {\n      throw buildError('canOnlyPlayNonFunctionWhenAtFirstTransfer')\n    }\n    return { ...state, mode }\n  }\n  return state\n}\n\nconst withPlayHomo: IPlayCard = ({ cards }) => state => {\n  if (state.mode === IMode.HOMO && !state.ignited) {\n    if (state.stage.length === 0) {\n      return { ...state }\n    }\n    const cardColor = getCardColor(cards[0])\n    if (cardColor !== ICardColor.NONE) {\n      if (!areCardsOfColor(cards, getCardColor(state.stage[0]))) {\n        throw buildError('canOnlyPlay$colorInThisHomoTransfer', {}, { color: cardColor })\n      }\n      return { ...state }\n    }\n  }\n  return state\n}\n\nconst withPlayHetero: IPlayCard = ({ cards }) => state => {\n  if (state.mode === IMode.HETERO && !state.ignited) {\n    if (state.stage.length === 0) {\n      return { ...state }\n    }\n    if (!hasCardColorNone(cards)) {\n      const type = getCardType(state.stage[0])\n      if (!areCardsOfDifferentColor([...state.stage, ...cards])) {\n        const stageColors = state.stage.map(card => getCardColor(card))\n        const colorsPlayed = cards.map(card => getCardColor(card)).filter(color => stageColors.includes(color))\n        const colorsCanPlay = allColors.filter(color => !stageColors.includes(color))\n        throw buildError('$colorsPlayedAnd$colorsCanPlayInThisHetero$typeTransfer', {}, {\n          type,\n          type2: type,\n          colorsPlayed,\n          colorsCanPlay\n        })\n      } else {\n        if (!areCardsOfTypeOrMagile(cards, type)) {\n          if (state.duel) {\n            throw buildError('youMayPlay$typeOnly', {}, { type })\n          } else {\n            throw buildError('youMayPlay$typeOrMagileOnly', {}, { type })\n          }\n        } else {\n          return { ...state }\n        }\n      }\n    }\n  }\n  return state\n}\n\nconst withPlayIgnite: IPlayCard = ({ cards }) => state => {\n  if (cards.length === 1) {\n    const card = cards[0]\n    if (card === ICard.HETERO_IGNITE) {\n      if (state.mode === IMode.HETERO) {\n        return { ...state, ignited: true }\n      } else {\n        throw buildError('cannotPlayHeteroIgniteDuringHomoTransfer')\n      }\n    }\n    if (card === ICard.HOMO_IGNITE) {\n      if (state.mode === IMode.HOMO) {\n        return { ...state, ignited: true }\n      } else {\n        throw buildError('cannotPlayHomoIgniteDuringHeteroTransfer')\n      }\n    }\n  }\n  return state\n}\n\nconst withPlayAngleGuard: IPlayCard = ({ cards }) => state => {\n  if (cards.length === 1) {\n    if (cards[0] === ICard.ANGEL_GUARD) {\n      return { ...state }\n    }\n  }\n  return state\n}\n\nconst withStateChangedValidation = (prevState: GameState): IPlayCard => () => state => {\n  if (prevState === state) {\n    throw buildError('invalidMove')\n  }\n  return state\n}\n\nexport const withIncrementTurn: IStateMapper = prevState => {\n  const nextPlayerId = (prevState.turn + prevState.players.length + prevState.direction) % prevState.players.length\n  return { ...prevState, turn: nextPlayerId }\n}\n\nconst withPlayCard: (playerId: number, payload: PlayCardPayload) => IStateMapper = (playerId, payload) => prevState => {\n  if (prevState.turn !== playerId) {\n    throw buildError('notYourTurn')\n  }\n  const nextState = compose(\n    // withCheckWin,\n    // withCheckHit,\n    withIncrementTurn,\n    withEnsureDuelNotFunctionCard(playerId),\n    withDrawCard(playerId),\n    ...[\n      withPutToPlayed,\n      withDiscardCard,\n      withStateChangedValidation(prevState),\n      withPlayAngleGuard,\n      withPlayIgnite,\n      withPlayHetero,\n      withPlayHomo,\n      withCardTypeValidation,\n      withFirstPlayValidation,\n      withCardNumberValidation\n    ].map(playCard => playCard(payload, playerId))\n  )(prevState)\n  return { ...nextState, lastAction: { ...payload, playerId } }\n}\n\nexport const withCheckWin: IStateMapper = state => {\n  const playerIdLose = state.playerHp.findIndex(hp => hp <= 0)\n  if (playerIdLose !== -1) {\n    return { ...state, winner: playerIdLose }\n  }\n  return state\n}\n\n// export const withCheckHit: IStateMapper = prevState => {\n//   if (ableToResponse(prevState)) {\n//     return prevState\n//   } else {\n//     return withHit(prevState)\n//   }\n// }\n\nconst withHit = (state: GameState): GameState => {\n  if (state.mode !== null) {\n    const { turn } = state\n    const hit = computeDamage(state)\n    const playerHp = [...state.playerHp]\n    playerHp[turn] -= hit\n    return {\n      ...state,\n      playerHp\n    }\n  }\n  return state\n}\n\nexport const withLog: (log: string) => IStateMapper = log => prevState => {\n  return { ...prevState, logs: [...prevState.logs, log] }\n}\n\nconst withCheckDiscardToHp: IPlayCard = (payload, playerId) => state => {\n  if (state.playerDeck[playerId].length - payload.cards.length !== state.playerHp[playerId]) {\n    const count = `${state.playerDeck[playerId].length - state.playerHp[playerId]}`\n    throw buildError('shouldDiscard$countCards', { count })\n  }\n  return state\n}\n\nconst withClearStage: IStateMapper = state => {\n  return {\n    ...state,\n    stage: [],\n    trashDeck: [...state.stage],\n    lastAction: null,\n    ignited: false,\n    duel: state.duel || state.playerHp[state.turn] <= 3,\n    mode: null\n  }\n}\n\nconst reorder = (cards: IDeck, playerId: number) => (state: GameState): GameState => {\n  if (!arraySameContent(cards, state.playerDeck[playerId])) {\n    throw new Error('Cards not consistent')\n  }\n  const playerDeck = [...state.playerDeck]\n  playerDeck[playerId] = cards\n  return { ...state, playerDeck }\n}\n\nexport const GameReducer: NetworkReducer<GameState, GameAction> = (prevState, action) => {\n  const peerId = action.peerId\n  if (peerId === undefined) {\n    throw new Error('Expect peerId in action')\n  }\n  const playerId = (): number => {\n    const id = prevState.nameDict[prevState.members[peerId]]\n    if (id === undefined) {\n      throw new Error('game not started')\n    }\n    return id\n  }\n  switch (action.type) {\n    case GameActionTypes.START:\n      return withInitGame(prevState)\n    case GameActionType.PLAY_CARD:\n      return withPlayCard(playerId(), action.payload)(JSON.parse(JSON.stringify(prevState)))\n    case GameActionType.DISCARD_CARD:\n      return compose(withEnsureDuelNotFunctionCard(playerId()), withClearStage, ...[withDiscardCard, withCheckDiscardToHp].map(step => step(action.payload, playerId())))(JSON.parse(JSON.stringify(prevState)))\n    case GameActionType.TAKE_HIT:\n      return withCheckWin(withHit(prevState))\n    case GameActionType.END:\n      return { ...prevState, started: false, ready: {} }\n    case GameActionType.REORDER:\n      return reorder(action.payload.cards, playerId())(prevState)\n  }\n  return prevState\n}\n","import { GameState } from './GameState'\nimport { GameAction, GameActionType } from './GameAction'\nimport { getCardColor, getCardType, isActionCard, randInt } from './utils'\nimport { allColors, ICard, ICardColor, ICardType, IDeck, IMode } from './types'\n\nconst countByColor = (hand: IDeck, excludeMagile: boolean): Record<ICardColor, number> => {\n  return hand\n    .map(card => getCardColor(card))\n    .filter(color => color !== ICardColor.NONE)\n    .filter(color => !excludeMagile || ![ICardColor.LIGHT, ICardColor.DARK].includes(color))\n    .reduce<Record<ICardColor, number>>(((previousValue, currentValue) => ({\n      ...previousValue,\n      [currentValue]: (previousValue[currentValue] ?? 0) + 1\n    })), {} as Record<ICardColor, number>)\n}\n\nconst countByTypeUniqueColor = (hand: IDeck, excludeMagile: boolean): Record<ICardType, number> => {\n  return hand\n    .filter(card => getCardColor(card) !== ICardColor.NONE)\n    .filter((card, k, cards) => cards.indexOf(card) === k)\n    .reduce<Record<ICardType, number>>(((record, card) => {\n      const type: ICardType = getCardType(card)\n      if(type === ICardType.MAGILE && excludeMagile) {\n        return record\n      }\n      if (type === ICardType.MAGILE && !excludeMagile) {\n        return {\n          [ICardType.MISSILE]: (record[ICardType.MISSILE] ?? 0) + 1,\n          [ICardType.MAGE]: (record[ICardType.MAGE] ?? 0) + 1\n        } as Record<ICardType, number>\n      }\n      return {\n        ...record,\n        [type]: (record[type] ?? 0) + 1\n      }\n    }), {} as Record<ICardType, number>)\n}\n\nconst sortDict = <T extends string | number> (dict: Record<T, number>): Array<[T, number]> => {\n  return Object.entries<number>(dict).sort((a, b) => (b[1] - a[1])) as Array<[T, number]>\n}\n\nconst buildPlayCardAction = (cards: ICard[], mode?: IMode): GameAction => {\n  return {\n    type: GameActionType.PLAY_CARD,\n    payload: {\n      cards,\n      mode\n    }\n  }\n}\n\nconst aiDiscard = (state: GameState, turn: number): GameAction => {\n  const hand: ICard[] = [...state.playerDeck[turn]]\n  const amountToDiscard = hand.length - state.playerHp[turn]\n  const discards: ICard[] = []\n  if (state.duel) {\n    while (discards.length < amountToDiscard && hand.find(isActionCard)) {\n      discards.push(hand.splice(hand.findIndex(isActionCard), 1)[0])\n    }\n  }\n  while (discards.length < amountToDiscard) {\n    discards.push(hand.splice(randInt(hand.length), 1)[0])\n  }\n  return {\n    type: GameActionType.DISCARD_CARD,\n    payload: {\n      cards: discards\n    }\n  }\n}\n\nconst aiFirstCard = (state: GameState, turn: number): GameAction => {\n  const hand: ICard[] = [...state.playerDeck[turn]]\n  const byColor: Array<[ICardColor, number]> = sortDict(countByColor(hand, true))\n  const byType: Array<[ICardType, number]> = sortDict(countByTypeUniqueColor(hand, state.duel))\n  const nextPlayerHp = state.playerHp[(turn + 1) % state.playerHp.length]\n  const magileCount = hand.filter(card => getCardType(card) === ICardType.MAGILE).length\n  const mode = state.playerHp[turn] !== 1 && nextPlayerHp !== 1 && !(byColor[0][1] + 1 <= byType[0][1] && magileCount < byType[0][1]) ? IMode.HOMO : IMode.HETERO\n  if (mode === IMode.HOMO) {\n    return buildPlayCardAction([hand.find((card) => getCardColor(card) === byColor[0][0]) as ICard], mode)\n  } else {\n    return buildPlayCardAction([hand.find((card) => getCardType(card) === byType[0][0]) as ICard], mode)\n  }\n}\n\nconst aiPlayCard = (state: GameState, playerId: number): GameAction => {\n  const hand = state.playerDeck[playerId]\n  const { mode, ignited, duel } = state\n  if (mode === IMode.HOMO) {\n    if(!ignited) {\n      const stageColor = getCardColor(state.stage[0])\n      const cards = hand.filter(card => getCardColor(card) === stageColor)\n      if (cards.length > 3) {\n        return buildPlayCardAction(cards.slice(0, 3))\n      }\n      if (cards.length > 0) {\n        return buildPlayCardAction([cards[0]])\n      }\n    }\n    if(!duel) {\n      const homoIgnite = hand.find(card => card === ICard.HOMO_IGNITE)\n      if(homoIgnite) {\n        return buildPlayCardAction([homoIgnite])\n      }\n      const angelGuard = hand.find(card => card === ICard.ANGEL_GUARD)\n      if(angelGuard) {\n        return buildPlayCardAction([angelGuard])\n      }\n    }\n  } else {\n    if(!ignited) {\n      const stageColors = state.stage.map(card => getCardColor(card))\n      const stageType = getCardType(state.stage[0])\n      const playableColors = new Set(allColors.filter(color => !stageColors.includes(color)))\n      const cards = hand.filter(card => {\n        const cardColor = getCardColor(card)\n        if(getCardType(card) === stageType && playableColors.has(cardColor)) {\n          playableColors.delete(cardColor)\n          return true\n        } else {\n          return false\n        }\n      })\n      if (cards.length > 3) {\n        return buildPlayCardAction(cards.slice(0, 3))\n      }\n      if (cards.length > 0) {\n        return buildPlayCardAction([cards[0]])\n      }\n    }\n    if(!duel) {\n      const heteroIgnite = hand.find(card => card === ICard.HETERO_IGNITE)\n      if(heteroIgnite) {\n        return buildPlayCardAction([heteroIgnite])\n      }\n      const angelGuard = hand.find(card => card === ICard.ANGEL_GUARD)\n      if(angelGuard) {\n        return buildPlayCardAction([angelGuard])\n      }\n    }\n  }\n  console.warn('AI PLAY CARD REACH EDGE CASE, TAKE HIT', state, playerId)\n  return {\n    type: GameActionType.TAKE_HIT\n  }\n}\n\nexport const aiAction = (state: GameState, turn: number): GameAction => {\n  if (state.playerDeck[turn].length > state.playerHp[turn]) {\n    return aiDiscard(state, turn)\n  }\n  if (state.stage.length === 0) {\n    return aiFirstCard(state, turn)\n  }\n  return aiPlayCard(state, turn)\n}\n","import React, { createContext, FunctionComponent, useContext, useEffect } from 'react'\nimport { BoardGameContextInterface, useBoardGameNetwork } from 'gamenet'\nimport { GameState } from './GameState'\nimport { GameReducer } from './GameReducer'\nimport { GameAction } from './GameAction'\nimport { aiAction } from './aiAction'\n\nconst Poker99Context = createContext<BoardGameContextInterface<GameState, GameAction> | null>(null)\n\nexport const withGameNetwork = (Component: FunctionComponent): FunctionComponent => {\n  const WithGameNetwork: FunctionComponent = props => {\n    const network = useBoardGameNetwork(GameReducer, new GameState(), undefined, 'magile')\n    const {myAis, state,dispatchAs} = network\n    useEffect(() => {\n      if (aiAction !== undefined && myAis.includes(state.players[state.turn]) && state.started && state.winner === null) {\n        const cb = (): void => {\n          const action = aiAction(state, state.turn)\n          // action.peerId = Object.keys(state.members).filter(peerId => state.members[peerId] === state.players[state.turn])[0]\n          dispatchAs(state.turn, action).catch(console.error)\n        }\n        const n = window.setTimeout(cb, 1000)\n        return () => {\n          window.clearTimeout(n)\n        }\n      }\n    }, [dispatchAs, myAis, state])\n    return (\n      <Poker99Context.Provider value={network}>\n        <Component {...props} />\n    </Poker99Context.Provider>\n  )\n  }\n  WithGameNetwork.displayName = 'WithGameNetwork'\n  return WithGameNetwork\n}\n\nexport const usePoker99 = (): BoardGameContextInterface<GameState, GameAction> => {\n  const network: BoardGameContextInterface<GameState, GameAction> | null = useContext(Poker99Context)\n  if (network === null) {\n    throw new Error('please wrap it using withGameNetwork before calling this hook')\n  }\n  return network\n}\n","import angel_guard from './angel_guard.png'\nimport dark_magile from './dark_magile.png'\nimport earth_mage from './earth_mage.png'\nimport earth_missile from './earth_missile.png'\nimport fire_mage from './fire_mage.png'\nimport fire_missile from './fire_missile.png'\nimport hetero_ignite from './hetero_ignite.png'\nimport homo_ignite from './homo_ignite.png'\nimport light_magile from './light_magile.png'\nimport thunder_mage from './thunder_mage.png'\nimport thunder_missile from './thunder_missile.png'\nimport water_mage from './water_mage.png'\nimport water_missile from './water_missile.png'\nimport wind_mage from './wind_mage.png'\nimport wind_missile from './wind_missile.png'\n\nexport const cardImages = {\n  angel_guard,\n  dark_magile,\n  earth_mage,\n  earth_missile,\n  fire_mage,\n  fire_missile,\n  hetero_ignite,\n  homo_ignite,\n  light_magile,\n  thunder_mage,\n  thunder_missile,\n  water_mage,\n  water_missile,\n  wind_mage,\n  wind_missile\n}\n","export default __webpack_public_path__ + \"static/media/angel_guard.16ea5f11.png\";","export default __webpack_public_path__ + \"static/media/dark_magile.1e723600.png\";","export default __webpack_public_path__ + \"static/media/earth_mage.e84ed39c.png\";","export default __webpack_public_path__ + \"static/media/earth_missile.c93568e4.png\";","export default __webpack_public_path__ + \"static/media/fire_mage.0e5240db.png\";","export default __webpack_public_path__ + \"static/media/fire_missile.6d251f43.png\";","export default __webpack_public_path__ + \"static/media/hetero_ignite.4942ab4f.png\";","export default __webpack_public_path__ + \"static/media/homo_ignite.0dedd4a2.png\";","export default __webpack_public_path__ + \"static/media/light_magile.787bb1b9.png\";","export default __webpack_public_path__ + \"static/media/thunder_mage.fea8f838.png\";","export default __webpack_public_path__ + \"static/media/thunder_missile.bb1203a2.png\";","export default __webpack_public_path__ + \"static/media/water_mage.c01f4c8a.png\";","export default __webpack_public_path__ + \"static/media/water_missile.fb44c368.png\";","export default __webpack_public_path__ + \"static/media/wind_mage.64b5492a.png\";","export default __webpack_public_path__ + \"static/media/wind_missile.c08191d4.png\";","import React, { FunctionComponent } from 'react'\nimport { ICard } from '../types'\nimport { makeStyles, Paper } from '@material-ui/core'\nimport { cardImages } from '../assets'\nimport { CheckCircleOutline } from 'mdi-material-ui'\nimport { green, red } from '@material-ui/core/colors'\nimport { CancelOutlined } from '@material-ui/icons'\nimport { useGamenetI18n } from 'gamenet-material'\n\nconst useStyle = makeStyles(() => ({\n  root: {\n    padding: '16px',\n    width: '110px',\n    height: '160px',\n    borderRadius: '8px',\n    cursor: 'pointer',\n    userSelect: 'none',\n    transition: 'transform 0.1s ease-in-out',\n    transformOrigin: 'center',\n    '&:hover': {\n      // transform: 'translateY(-50%)'\n    }\n  }\n}))\n\nexport const Card: FunctionComponent<{\n  card: ICard, onClick?: () => void, disabled?: boolean, style?: Record<string, unknown>, selected?: boolean, isDelete?: boolean\n}> = (\n  {\n    style,\n    card,\n    onClick,\n    disabled,\n    selected,\n    isDelete\n  }) => {\n  const classes = useStyle()\n  const {i18n} = useGamenetI18n()\n\n  return (\n    <Paper\n      elevation={4}\n      style={{\n        pointerEvents: disabled ? 'none' : 'auto',\n        backgroundImage: `url(${cardImages[card]})`,\n        backgroundSize: 'cover',\n        position: 'relative',\n        textAlign: 'left',\n        ...style\n      }}\n      className={classes.root} onClick={!disabled ? onClick : undefined}>\n      <h2 style={{ fontFamily: 'Big Shoulders Inline Text, inherit', margin: 0, color: 'white', textShadow: '5px 3px 8px black' }}>\n        {i18n[card]}\n      </h2>\n      {selected && <div style={{position: 'absolute', top: 0, right: 0}}>\n        {isDelete ? <CancelOutlined style={{ color: red[500] }} fontSize='large'/> : <CheckCircleOutline style={{ color: green[500] }} fontSize='large'/>}\n      </div>}\n    </Paper>\n  )\n}\n","import React, { FunctionComponent, useEffect, useMemo, useState } from 'react'\nimport { usePoker99 } from './withGameNetwork'\nimport { GameAction, GameActionType, PlayCardPayload } from './GameAction'\nimport { ChooseCardFor, Deck } from './components/Deck'\nimport { Button, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle } from '@material-ui/core'\nimport { checkAbleToRespond, decodeError } from './utils'\nimport { useGamenetI18n } from 'gamenet-material'\nimport { IDeck } from './types'\n\nexport const Game: FunctionComponent = () => {\n  const {\n    state,\n    dispatch,\n    dispatchAs,\n    myPlayerId,\n    myLocals,\n    hideDeck,\n    setHideDeck,\n    error,\n    setError,\n    renderedDeckId\n  } = usePoker99()\n  const [throttledRenderedId, setTrottledRenderedId] = useState(renderedDeckId)\n  const {i18n} = useGamenetI18n()\n  const handleError = (e: Error): void => {\n    console.error('HANDLE ERROR')\n    try {\n      setError(decodeError(e, i18n))\n    } catch {\n      setError(e.message)\n    }\n  }\n  const myTurn = state.turn === myPlayerId || myLocals.includes(state.players[state.turn])\n  const dispatchHelper = async (action: GameAction) => {\n    try{\n      if (state.turn === myPlayerId) {\n        await dispatch(action).then(() => setError(''))\n      } else if (myLocals.includes(state.players[state.turn])) {\n        await dispatchAs(state.turn, action).then(() => setError(''))\n      } else {\n        throw new Error('Not my turn')\n      }\n    } catch (e) {\n      handleError(e)\n      throw e\n    }\n  }\n  const playCard = async (payload: PlayCardPayload) => {\n    const action: GameAction = {\n      type: GameActionType.PLAY_CARD,\n      payload\n    }\n    await dispatchHelper(action).then(() => {\n      if (myLocals.length > 0) {\n        setHideDeck(true)\n      }\n    })\n  }\n  const discardCard = async (payload: PlayCardPayload) => {\n    const action: GameAction = {\n      type: GameActionType.DISCARD_CARD,\n      payload\n    }\n    await dispatchHelper(action)\n  }\n  const takeHit = async () => {\n    const action: GameAction = {\n      type: GameActionType.TAKE_HIT,\n    }\n    await dispatchHelper(action)\n  }\n  useEffect(() => {\n    setTimeout(() => {\n      setTrottledRenderedId(renderedDeckId)\n    }, 500)\n  }, [renderedDeckId])\n  useEffect(() => {\n    setTrottledRenderedId(myPlayerId)\n  }, [myPlayerId])\n  const ableToRespond = useMemo(() => checkAbleToRespond(state), [state])\n  let chooseCardFor = ChooseCardFor.RESPOND_PLAY\n  if(state.stage.length === 0) {\n    chooseCardFor = ChooseCardFor.FIRST_PLAY\n  }\n  if(state.started && throttledRenderedId !== undefined && throttledRenderedId !== null && state.playerDeck[throttledRenderedId].length > state.playerHp[throttledRenderedId]) {\n    chooseCardFor = ChooseCardFor.DISCARD\n  }\n  const handleCardChoose = async (payload: PlayCardPayload) => {\n    if(chooseCardFor === ChooseCardFor.DISCARD) {\n      await discardCard(payload)\n    } else {\n      await playCard(payload)\n    }\n  }\n  const onReorder = async (cards: IDeck): Promise<void> => {\n    await dispatch({\n      type: GameActionType.REORDER,\n      payload: {\n        cards\n      }\n    }).catch(handleError)\n  }\n  return (\n    <div style={{ pointerEvents: 'all', color: 'white' }}>\n      {state.started && myPlayerId !== undefined &&\n      <Deck\n        cards={state.playerDeck[throttledRenderedId ?? myPlayerId]}\n        onCardsChoose={handleCardChoose}\n        chooseCardFor={chooseCardFor}\n        hide={hideDeck}\n        reveal={() => setHideDeck(false)}\n        takeHit={takeHit}\n        myTurn={myTurn}\n        onReorder={onReorder}\n        ableToRespond={ableToRespond}\n      />}\n      <div style={{ maxHeight: '50%' }}>\n        {state.logs.slice().reverse().map((s, k) => <div key={k}>{s}</div>)}\n      </div>\n      <Dialog open={error !== ''} onClose={() => setError('')} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle>Error</DialogTitle>\n        <DialogContent>\n          <DialogContentText>\n            {error}\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setError('')} color=\"primary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  )\n}\n","import React, { FunctionComponent } from 'react'\nimport { Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow } from '@material-ui/core'\nimport { useGamenetI18n } from 'gamenet-material'\n\nexport const DamageTable: FunctionComponent = () => {\n  const { i18n } = useGamenetI18n()\n  return (\n    <TableContainer component={Paper}>\n      <Table style={{ width: '100%' }} size=\"small\">\n        <TableHead>\n          <TableRow>\n            <TableCell>{i18n.transferMode}</TableCell>\n            <TableCell>{i18n.mmmCount}</TableCell>\n            <TableCell>{i18n.damage}</TableCell>\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          <TableRow>\n            <TableCell rowSpan={3}>{i18n.homo}</TableCell>\n            <TableCell>1 - 4</TableCell>\n            <TableCell>1</TableCell>\n          </TableRow>\n          <TableRow>\n            <TableCell>5 - 7</TableCell>\n            <TableCell>2</TableCell>\n          </TableRow>\n          <TableRow>\n            <TableCell>8+</TableCell>\n            <TableCell>3</TableCell>\n          </TableRow>\n          <TableRow>\n            <TableCell rowSpan={3}>{i18n.hetero}</TableCell>\n            <TableCell>1 - 4</TableCell>\n            <TableCell>1</TableCell>\n          </TableRow>\n          <TableRow>\n            <TableCell>5 - 6</TableCell>\n            <TableCell>2</TableCell>\n          </TableRow>\n          <TableRow>\n            <TableCell>7</TableCell>\n            <TableCell>3</TableCell>\n          </TableRow>\n        </TableBody>\n      </Table>\n    </TableContainer>\n  )\n}\n","import { FunctionComponent, useState } from 'react'\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  IconButton\n} from '@material-ui/core'\nimport { Information } from 'mdi-material-ui'\nimport React from 'react'\nimport { useGamenetI18n } from 'gamenet-material'\nimport { DamageTable } from './DamageTable'\n\n\nexport const DamageTableToggleButton: FunctionComponent = () => {\n  const [open, setOpen] = useState(false)\n  const { i18n } = useGamenetI18n()\n  return (\n    <div style={{ position: 'fixed', left: 0, bottom: 0 }}>\n      <IconButton onClick={() => setOpen(true)}>\n        <Information/>\n      </IconButton>\n      <Dialog open={open} onClose={() => setOpen(false)} aria-labelledby=\"form-dialog-title\">\n        <DialogTitle>{i18n.damageTable}</DialogTitle>\n        <DialogContent>\n          <DamageTable/>\n          <DialogContentText>\n            {i18n.damageTableHint}\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpen(false)} color=\"primary\">\n            {i18n.close}\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  )\n}\n","import React, { FunctionComponent, useEffect, useMemo, useState } from 'react'\nimport { usePoker99 } from '../withGameNetwork'\nimport { GameActionType } from '../GameAction'\nimport { Card } from './Card'\nimport { IDeck, IMode } from '../types'\nimport { computeDamage } from '../utils'\nimport { Button } from '@material-ui/core'\nimport { i18nSub, useGamenetI18n } from 'gamenet-material'\nimport { DamageTableToggleButton } from '../DamageTableToggleButton'\n\nexport const GameRenderer: FunctionComponent = () => {\n  const { state, myPlayerId, dispatch } = usePoker99()\n  const [prevCardPayload, setPrevCardPayload] = useState<null | IDeck>(null)\n  const [startAnimateCard, setStartAnimateCard] = useState(false)\n  const [showAnimateCard, setShowAnimateCard] = useState(false)\n  const { i18n } = useGamenetI18n()\n  useEffect(() => {\n    setShowAnimateCard(true)\n    setTimeout(() => {\n      setStartAnimateCard(true)\n    }, 1)\n    setTimeout(() => {\n      setPrevCardPayload(state.stage)\n      setStartAnimateCard(false)\n      setShowAnimateCard(false)\n    }, 300)\n  }, [state.lastAction, state.stage])\n  const mp = (id: number): number => (id + state.playerHp.length) % state.playerHp.length\n  const center = {\n    top: '50vh',\n    left: '50vw'\n  }\n  const again = async (): Promise<void> => {\n    await dispatch({\n      type: GameActionType.END\n    }).catch(console.error)\n  }\n  const status = (() => {\n    if (state.started) {\n      if (state.winner !== null) {\n        const player = state.players[state.winner]\n        return i18nSub(i18n.loserIs$player, { player })\n      }\n      const player = state.players[state.turn]\n      if (state.playerDeck[state.turn].length > state.playerHp[state.turn]) {\n        return i18nSub(i18n.$playerDiscardCardTil$cardCount, { player, cardCount: `${state.playerHp[state.turn]}` })\n      }\n      if (state.stage.length === 0) {\n        return i18nSub(i18n.$playerInitializingTransfer, { player })\n      } else {\n        const mode = i18n[state.mode ?? IMode.HOMO]\n        return i18nSub(i18n.$playerRespondTo$modeTransfer, { player, mode })\n      }\n    }\n    return undefined\n  })()\n  const damage = useMemo(() => `${computeDamage(state)}`, [state])\n  const hint = (() => {\n    if (state.started) {\n      if (state.playerDeck[state.turn].length > state.playerHp[state.turn]) {\n        return i18nSub(i18n.hit$playerWith$damage, { player: state.players[state.turn], damage })\n      }\n      if (state.winner !== null) {\n        return i18n.gameOver\n      }\n      if (state.duel) {\n        return i18n.duelHint\n      }\n      if (state.ignited) {\n        return i18n.ignitedHint\n      }\n    }\n    return undefined\n  })()\n  return (\n    !state.started\n      ? <div\n        style={{ backgroundColor: 'green', position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, color: 'white' }}\n      />\n      : <div\n        style={{\n          backgroundColor: 'green',\n          position: 'fixed',\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0,\n          color: 'white',\n          boxShadow: state.duel ? 'inset 0 0 100px #ff9d9d' : undefined,\n          transition: 'box-shadow 0.3s ease-in-out'\n        }}>\n        <div style={{ display: 'flex', justifyContent: 'space-around', margin: 'auto' }}>\n          {\n            new Array(state.players.length).fill(0).map((_, k) => mp(k + (myPlayerId ?? 0))).filter(id => id !== (myPlayerId ?? 0)).map(id => (\n              <div style={{ border: `solid ${state.turn === id ? 'red' : 'transparent'} 2px`, padding: '16px 32px' }}>\n                <div>\n                  {state.players[id]}\n                </div>\n                <div>\n                  hp: {state.playerHp[id]}\n                </div>\n              </div>\n            ))\n          }\n        </div>\n        {/*{myPlayerId === undefined && <Name offset={0}/>}*/}\n        {prevCardPayload !== null &&\n        <div style={{ position: 'absolute', ...center }}>\n          <div style={{ transform: 'translate(-50%,-100%)', textAlign: 'center' }}>\n            {hint && <h3>{hint}</h3>}\n            <h1>{status}</h1>\n            {state.winner !== undefined && state.winner !== null && <div>\n              <Button variant=\"contained\" color='primary' onClick={again}>{i18n.again}</Button>\n            </div>}\n            <h3>{state.mode && `${i18n[state.mode]}, `}{i18nSub(i18n.current$damage, { damage })}</h3>\n            <div style={{\n              display: 'flex',\n              justifyContent: 'center',\n              maxWidth: 'calc(100vw - 32px)',\n              flexWrap: 'wrap',\n              marginRight: 'auto',\n              marginLeft: 'auto',\n              marginBottom: '70px'\n            }}>\n              {prevCardPayload.map(card => <div style={{ padding: '8px', maxHeight: '70px' }}><Card card={card} disabled/>\n              </div>)}\n            </div>\n          </div>\n        </div>}\n        {showAnimateCard && state.lastAction !== null && <div style={{\n          display: 'flex',\n          position: 'absolute',\n          left: '50vw',\n          top: startAnimateCard ? '50vh' : state.lastAction.playerId === myPlayerId ? '100vh' : '-100%',\n          transition: ['top', 'bottom', 'left', 'right'].map(s => `${s} 0.2s ease-in-out`).join(',')\n        }}>\n          <div style={{ transform: 'translate(-50%,-50%)', display: 'flex' }}>\n            {state.lastAction.cards.map(card => <div style={{ padding: '8px' }}><Card card={card} disabled/></div>)}\n          </div>\n        </div>}\n        <h3 style={{\n          position: 'absolute',\n          bottom: 0,\n          right: '20px',\n          textAlign: 'right',\n          border: `solid ${state.turn === (myPlayerId ?? 0) ? 'red' : 'transparent'} 2px`,\n          padding: '16px 32px'\n        }}>\n          <div>\n            {i18n.name}: {state.players[myPlayerId ?? 0]}\n          </div>\n          <div>\n            hp: {state.playerHp[myPlayerId ?? 0]}\n          </div>\n          <div>\n            {i18n.drawDeck}: {state.drawDeck.length}\n          </div>\n        </h3>\n        <DamageTableToggleButton/>\n      </div>\n  )\n}\n","import React from 'react'\nimport { DamageTable } from '../DamageTable'\n\nexport const howToPlay = (\n  <div>\n    <h1>Magile</h1>\n    <h2>Story</h2>\n    <p>\n      In a magical kingdom, there were some wizards. They always research a weapon called \"Mage\", a very powerful magic.\n    </p>\n    <p>\n      One day they met some engineers who were fans of ancient technologies. The engineers mixed ancient technologies\n      with modern magic, and created a new weapon called \"Missile\", challenged the cute wizards.\n    </p>\n    <p>\n      A battle between Mages and Missiles starts now!\n    </p>\n    <h2>Cards</h2>\n    <h4>Basic cards:</h4>\n    <ul>\n      <li>Mages*45: Earth, Water, Fire, Wind, Thunder each *9</li>\n      <li>Missile*45: Earth, Water, Fire, Wind, Thunder each *9</li>\n    </ul>\n    <h4>Function cards:</h4>\n    <ul>\n      <li>Magiles*6: Light, Dark each *3</li>\n      <li>Ignite*6: Homo, Hetero each *3</li>\n      <li>Angel Guard*6</li>\n    </ul>\n    <h2>How To Play</h2>\n    <ol>\n      <li>Choose first player randomly to initiate a transfer</li>\n      <li>Initiate transfer: choose one missile or mage and decide whether is it a homo transfer or hetero transfer</li>\n      <li>\n        <div>Next player respond to the transfer</div>\n        <ul>\n          <li>if it is a homo transfer, you can either\n            <ul>\n              <li>play 1/3 mage/missile of same color</li>\n              <li>or play a homo ignite</li>\n            </ul>\n          </li>\n          <li>if it is a hetero transfer, you can either\n            <ul>\n              <li>play 1/3 mage/missle/magile of color that were not played\n                yet, and same type as the first card(mage/missile), where magile is both a mage and a missile\n              </li>\n              <li>or play a hetero ignite</li>\n            </ul>\n          </li>\n          <li>If someone played an ignite at this transfer, you can only respond with same ignite or angel guard, each additional ignite +1 damage (that is first ignite dont have damage)</li>\n          <li>respond with an angel guard</li>\n          <li>give up respond and take damage</li>\n        </ul>\n      </li>\n      <li>After playing card, draw cards until number of cards = hp</li>\n      <li>\n        If cannot respond will be damaged. The amount refer to the damage table. Discard until number of cards = hp.\n        Same player initiate a new transfer\n      </li>\n      <li>If anyone hp {'<='} 3, game will enter duel mode. During duel mode all damage +1 and function card stop working (cannot respond with magile/ignite/angel guard). Effective to all players</li>\n      <li>If anyone hp {'<='} 0, game end and he is the only loser, the rest win</li>\n    </ol>\n    <h2>Damage Table</h2>\n    <DamageTable/>\n    <p>After playing first ignite in the transfer, each additional ignite damage+1; during duel damage+1.</p>\n  </div>\n)\n","import { gamenetI18n } from 'gamenet-material'\nimport { ICard, ICardColor, ICardType, IMode } from '../types'\nimport { howToPlay } from './howToPlay.en'\n\nexport const en = {\n  ...gamenetI18n.en,\n  gameName: 'Magile',\n  howToPlay: 'How To Play',\n  howToPlayContent: howToPlay,\n  [IMode.HOMO]: 'Homo Transfer',\n  [IMode.HETERO]: 'Hetero Transfer',\n  [ICardType.MAGE]: 'Mage',\n  [ICardType.MISSILE]: 'Missile',\n  [ICardType.MAGILE]: 'Magile',\n  [ICardType.IGNITE]: 'Ignite',\n  [ICardType.ANGEL_GUARD]: 'Angel Guard',\n  [ICardColor.NONE]: 'None',\n  [ICardColor.EARTH]: 'Earth',\n  [ICardColor.WATER]: 'Water',\n  [ICardColor.FIRE]: 'Fire',\n  [ICardColor.WIND]: 'Wind',\n  [ICardColor.THUNDER]: 'Thunder',\n  [ICardColor.LIGHT]: 'Light',\n  [ICardColor.DARK]: 'Dark',\n  [ICard.EARTH_MAGE]: 'Earth Mage',\n  [ICard.WATER_MAGE]: 'Water Mage',\n  [ICard.FIRE_MAGE]: 'Fire Mage',\n  [ICard.WIND_MAGE]: 'Wind Mage',\n  [ICard.THUNDER_MAGE]: 'Thunder Mage',\n  [ICard.EARTH_MISSILE]: 'Earth Missile',\n  [ICard.WATER_MISSILE]: 'Water Missile',\n  [ICard.FIRE_MISSILE]: 'Fire Missile',\n  [ICard.WIND_MISSILE]: 'Wind Missile',\n  [ICard.THUNDER_MISSILE]: 'Thunder Missile',\n  [ICard.LIGHT_MAGILE]: 'Light Magile',\n  [ICard.DARK_MAGILE]: 'Dark Magile',\n  [ICard.HOMO_IGNITE]: 'Homo Ignite',\n  [ICard.HETERO_IGNITE]: 'Hetero Ignite',\n  [ICard.ANGEL_GUARD]: 'Angel Guard',\n  gameOver: 'Game Over',\n  duelHint: 'DUEL! NO Function card and each hit will deduct 1 more hp!',\n  igniteHint: 'IGNITED! Respond only with same ignited or angel guard!',\n  loserIs$player: 'Loser is {{player}}',\n  $playerDiscardCardTil$cardCount: '{{player}} discard card til {{cardCount}}',\n  $playerInitializingTransfer: '{{player}} initializing transfer',\n  $playerRespondTo$modeTransfer: '{{player}} responding to {{mode}}.',\n  current$damage: 'Current damage: {{damage}}',\n  again: 'Again',\n  drawDeck: 'Draw Deck',\n  notYourTurn: 'Not Your Turn',\n  takeHit: 'Take Hit',\n  areYouSureYouWantToTakeHit: 'Are you sure you want to take hit?',\n  respond: 'Respond',\n  initializeHomoTransfer: 'Initialize Homo Transfer',\n  initializeHeteroTransfer: 'Initialize Hetero Transfer',\n  trash: 'Trash',\n  cannotDraw$playerAlreadyHas$countCards: `cannot draw, {{player}} already has {{count}} cards`,\n  $playerDoesNotOwnCard$card: '{{player}} doesnt own card {{card}}',\n  playerCardMoreThanHp: 'Player has card more than his hp, please discard',\n  cannotMixIgniteAngelWithMagiles: 'cannot mix ignite or angel card with mage, missiles and magiles',\n  cannotPlayFunctionDuringDuel: 'cannot play function card during duel',\n  canPlayOnly1Or3Cards: 'you can only play 1 card or 3 cards',\n  specifyHomoOrHeteroAtFirstTransfer: 'please specify homo transfer or hetero transfer as the first to transfer',\n  canOnlyDoHeteroWhenNextIs1hp: 'can only do hetero transfer when next player is 1 hp',\n  canOnlyPlay1CardWhenAtFirstTransfer: 'please play one card as the first to transfer',\n  canOnlyPlayNonFunctionWhenAtFirstTransfer: 'cannot play function type as the first to transfer',\n  canOnlyPlay$colorInThisHomoTransfer: 'cannot play color other than {{color}} in this homo transfer',\n  $colorsPlayedAnd$colorsCanPlayInThisHetero$typeTransfer: '{{colorsPlayed}} {{type}} played. You may play {{colorsCanPlay}} {{type2}} in this hetero transfer',\n  youMayPlay$typeOnly: 'You may play {{type}} only',\n  youMayPlay$typeOrMagileOnly: 'You may play {{type}} or Magile only',\n  cannotPlayHomoIgniteDuringHeteroTransfer: 'Cannot Play Homo Ignite during Hetero transfer',\n  cannotPlayHeteroIgniteDuringHomoTransfer: 'Cannot Play Hetero Ignite during Homo transfer',\n  invalidMove: 'invalidMove',\n  shouldDiscard$countCards: 'should discard {{count}} cards',\n  transferMode: 'Transfer Mode',\n  mmmCount: 'Mage/Missile/Magile count on stage',\n  damage: 'Damage',\n  damageTableHint: 'After playing first ignite in the transfer, each additional ignite damage+1; during duel damage+1.',\n  damageTable: 'Damage Table',\n  close: 'close',\n  notAbleToRespond: 'Not able to respond',\n  hit$playerWith$damage: 'Hit {{player}} causing {{damage}} damage'\n}\n","import React from 'react'\nimport { DamageTable } from '../DamageTable'\n\nexport const howToPlay = (\n  <div>\n    <h1>魔法飛彈大作戰</h1>\n    <h2>故事</h2>\n    <p>\n      在某個魔法王國裡，居住著一群「魔導師」，\n      她們成天研究一種稱為「魔彈」的法術，是種非常強大的法術。\n    </p>\n    <p>\n      但有天她們遇上了崇尚古文明的「機械師」，機械師將古代科技融合至現代魔法中，\n      創造出了一種名為「飛彈」的武器，向這群可愛的魔導師們發起了挑戰。\n    </p>\n    <p>\n      魔彈與飛彈的比拚，就在此拉開序幕!\n    </p>\n    <h2>所有卡牌</h2>\n    <h4>基礎牌:</h4>\n    <ul>\n      <li>魔彈卡45張：地、水、火、風、雷五系魔彈各9張</li>\n      <li>飛彈卡45張：地、水、火、風、雷五系飛彈各9張</li>\n    </ul>\n    <h4>功能牌:</h4>\n    <ul>\n      <li>魔法飛彈卡6張：光系魔法飛彈卡3張、暗系魔法飛彈卡3張</li>\n      <li>引爆卡6張：同系引爆卡3張、異系引爆卡3張</li>\n      <li>庇護卡6張：天使的庇護卡6張</li>\n    </ul>\n    <h2>玩法</h2>\n    <ol>\n      <li>隨機一個玩家發動首輪傳遞</li>\n      <li>發動傳遞: 由該玩家打出1張魔彈或是飛彈，並且聲明一種傳遞方式(同系/異系)。</li>\n      <li>\n        <div>下個玩家響應傳遞</div>\n        <ul>\n          <li>如果是同系傳遞，可以\n            <ul>\n              <li>打出一或三張同系卡(魔彈飛彈都可以)</li>\n              <li>或打出同系引爆</li>\n            </ul>\n          </li>\n          <li>如果是異系傳遞，可以\n            <ul>\n              <li>打出一或三張未打出過的異系卡，如果發起者打出的是魔彈，只能打出魔彈，飛彈亦然。魔法飛彈是魔彈亦是飛彈。\n              </li>\n              <li>或打出異系引爆</li>\n            </ul>\n          </li>\n          <li>如果今輪有人打出引爆，你只能用同一種引爆或天使的庇護作響應。每張再加的引爆+1傷害(即第一張引爆沒有傷害)</li>\n          <li>以天使的庇護作響應</li>\n          <li>以生命值硬接</li>\n        </ul>\n      </li>\n      <li>每次打牌後，抽牌直至手牌數與血量一樣</li>\n      <li>\n        如果沒能作出響應，則只能用生命值硬接。傷害請見傷害表。棄牌至手牌數與血量一致，然後同一玩家發動下一輪傳遞\n      </li>\n      <li>如果有人血量低於或等於3，遊戲進入大決戰。大決戰期間所有傷害+1，所有功能牌失效 (所有人不能打出魔法飛彈、引爆和庇護)</li>\n      <li>如果有人血量低於或等於0，遊戲結束，該玩家成為唯一輪家，其餘人獲勝</li>\n    </ol>\n    <h2>傷害表</h2>\n    <DamageTable/>\n    <p>\n      打出一張引爆卡後，其後每張引爆傷害+1。大決戰其間傷害+1\n    </p>\n  </div>\n)\n","import { en } from './en'\nimport { zh } from './zh'\n\nexport const i18ns = {\n  en,\n  zh\n}\n","import { gamenetI18n } from 'gamenet-material'\nimport { ICard, ICardColor, ICardType, IMode } from '../types'\nimport { howToPlay } from './howToPlay.zh'\n\nexport const zh = {\n  ...gamenetI18n.zh,\n  gameName: '魔法飛彈大作戰',\n  howToPlay: '玩法',\n  howToPlayContent: howToPlay,\n  [IMode.HOMO]: '同系傳遞',\n  [IMode.HETERO]: '異系傳遞',\n  [ICardType.MAGE]: '魔彈',\n  [ICardType.MISSILE]: '飛彈',\n  [ICardType.MAGILE]: '魔法飛彈',\n  [ICardType.IGNITE]: '引爆',\n  [ICardType.ANGEL_GUARD]: '天使的庇護',\n  [ICardColor.NONE]: '無屬性',\n  [ICardColor.EARTH]: '地系',\n  [ICardColor.WATER]: '水系',\n  [ICardColor.FIRE]: '火系',\n  [ICardColor.WIND]: '風系',\n  [ICardColor.THUNDER]: '雷系',\n  [ICardColor.LIGHT]: '光系',\n  [ICardColor.DARK]: '暗系',\n  [ICard.EARTH_MAGE]: '地系魔彈',\n  [ICard.WATER_MAGE]: '水系魔彈',\n  [ICard.FIRE_MAGE]: '火系魔彈',\n  [ICard.WIND_MAGE]: '風系魔彈',\n  [ICard.THUNDER_MAGE]: '雷系魔彈',\n  [ICard.EARTH_MISSILE]: '地系飛彈',\n  [ICard.WATER_MISSILE]: '水系飛彈',\n  [ICard.FIRE_MISSILE]: '火系飛彈',\n  [ICard.WIND_MISSILE]: '風系飛彈',\n  [ICard.THUNDER_MISSILE]: '雷系飛彈',\n  [ICard.LIGHT_MAGILE]: '光系魔法飛彈',\n  [ICard.DARK_MAGILE]: '暗系魔法飛彈',\n  [ICard.HOMO_IGNITE]: '同系引爆',\n  [ICard.HETERO_IGNITE]: '異系引爆',\n  [ICard.ANGEL_GUARD]: '天使的庇護',\n  gameOver: '遊戲結束',\n  duelHint: '大決戰! 功能卡失效，每次傷害+1!',\n  igniteHint: '引爆! 只可以用同一種引爆或天使的庇護作響應!',\n  loserIs$player: '輸家是{{player}}',\n  $playerDiscardCardTil$cardCount: '{{player}}棄牌至{{cardCount}}張',\n  $playerInitializingTransfer: '{{player}}開始傳遞',\n  $playerRespondTo$modeTransfer: '{{player}}響應{{mode}}',\n  current$damage: '目前累積傷害: {{damage}}',\n  again: '再玩一次',\n  drawDeck: '抽牌區',\n  notYourTurn: '不是你的回合哦~',\n  takeHit: '用生命值硬接',\n  areYouSureYouWantToTakeHit: '你確定要用生命值硬接?',\n  respond: '響應',\n  initializeHomoTransfer: '發動同系傳遞',\n  initializeHeteroTransfer: '發動異系傳遞',\n  trash: '棄卡',\n  cannotDraw$playerAlreadyHas$countCards: `不能抽卡, {{player}}已經有{{count}}張卡`,\n  $playerDoesNotOwnCard$card: '{{player}}沒有{{card}}',\n  playerCardMoreThanHp: '玩家有多於他血量的卡，請棄卡',\n  cannotMixIgniteAngelWithMagiles: '引爆和天使卡不能與其他卡混用',\n  cannotPlayFunctionDuringDuel: '大決戰期間不能用功能卡',\n  canPlayOnly1Or3Cards: '你只能打出一張或三張卡',\n  specifyHomoOrHeteroAtFirstTransfer: '發動傳遞時請指明同系或異系傳遞',\n  canOnlyDoHeteroWhenNextIs1hp: '當下家只有1血時只能發動異系傳遞',\n  canOnlyPlay1CardWhenAtFirstTransfer: '發動傳遞時只能打出一張卡',\n  canOnlyPlayNonFunctionWhenAtFirstTransfer: '發動傳遞時不能打出功能卡',\n  canOnlyPlay$colorInThisHomoTransfer: '此同系傳遞只能打出{{color}}',\n  $colorsPlayedAnd$colorsCanPlayInThisHetero$typeTransfer: '{{colorsPlayed}}{{type}}已經有人打出。這場異系傳遞你可以打出{{colorsCanPlay}}{{type2}}',\n  youMayPlay$typeOnly: '你只能打出{{type}}',\n  youMayPlay$typeOrMagileOnly: '你只能打出{{type}}或者魔法飛彈',\n  cannotPlayHomoIgniteDuringHeteroTransfer: '異系傳遞不能打出同系引爆',\n  cannotPlayHeteroIgniteDuringHomoTransfer: '同系傳遞不能打出異系引爆',\n  invalidMove: '不允許的行動',\n  shouldDiscard$countCards: '請棄{{count}}張卡',\n  transferMode: '傳遞模式',\n  mmmCount: '場上魔彈/飛彈/魔法飛彈數量',\n  damage: '傷害',\n  damageTableHint: '打出一張引爆卡後，其後每張引爆傷害+1。大決戰其間傷害+1',\n  damageTable: '傷害表',\n  close: '關閉',\n  notAbleToRespond: '沒有可以響應的卡',\n  hit$playerWith$damage: '命中{{player}}並造成{{damage}}點傷害'\n}\n","import React, { FunctionComponent } from 'react'\nimport { usePoker99, withGameNetwork } from './withGameNetwork'\nimport { GamePagesSlider, Home, LanguageButton, Room, useGamenetI18n, withGamenetI18n } from 'gamenet-material'\nimport { Game } from './Game'\nimport { GameRenderer } from './components/GameRenderer'\nimport { i18ns } from './i18ns'\nimport { DialogContent } from '@material-ui/core'\nimport { withLobby } from 'gamenet'\n\nconst App: FunctionComponent = withLobby(withGamenetI18n({ i18ns })(withGameNetwork(() => {\n  const network = usePoker99()\n  const { i18n } = useGamenetI18n()\n  return (\n    <GamePagesSlider gameAppState={network.gameAppState} fullPage={[false, false, true]} GameRenderer={<GameRenderer/>}>\n      <Home {...network} gameName={i18n.gameName}>\n        <DialogContent>\n          {i18n.howToPlayContent}\n        </DialogContent>\n      </Home>\n      <Room {...network} />\n      <Game/>\n      <div style={{ position: 'fixed', top: 0, right: 0, zIndex: 100 }}>\n        <LanguageButton/>\n      </div>\n    </GamePagesSlider>\n  )\n})))\n\nexport default App\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}